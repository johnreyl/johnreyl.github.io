<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Voxel Strategy Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-..." crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none; /* Disables touch scrolling to allow Babylon.js touch control */
        }

        .ui-panel {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            backdrop-filter: blur(8px);
        }
        /* Custom class for active toggle buttons */
        .toggle-active {
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.7); /* Green glow */
            border: 2px solid #4ade80;
        }
        /* Ensure the collapsed panel is truly hidden visually by setting max-width to 0 */
        .max-w-0 {
            max-width: 0 !important;
        }
    </style>
    <style>
        /* Base glow for the title */
        .text-shadow-glow {
            /* Subtle blue-tinged glow */
            text-shadow: 0 0 5px rgba(100, 149, 237, 0.5), 0 0 10px rgba(100, 149, 237, 0.3);
        }

        /* Define the keyframe animation */
        @keyframes pulse-title {
            0% {
                /* Base state: subtle glow */
                text-shadow: 0 0 5px rgba(100, 149, 237, 0.5), 0 0 10px rgba(100, 149, 237, 0.3);
            }

            50% {
                /* Pulsed state: brighter, wider glow */
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.7), /* White core */
                0 0 30px rgba(66, 165, 245, 0.8), /* Stronger blue halo */
                0 0 45px rgba(66, 165, 245, 0.5); /* Outer blue dispersion */
            }

            100% {
                /* Return to base state */
                text-shadow: 0 0 5px rgba(100, 149, 237, 0.5), 0 0 10px rgba(100, 149, 237, 0.3);
            }
        }

        /* Apply the animation to the custom class */
        .title-pulse {
            animation: pulse-title 3s infinite ease-in-out; /* Slower, more pronounced pulse */
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'team-a': '#EF4444', // Red 500
                        'team-b': '#3B82F6', // Blue 500
                    }
                }
            }
        }
    </script>

</head>
<body class="bg-gray-900 h-screen w-screen overflow-hidden flex items-center justify-center">

    <canvas id="renderCanvas" class="absolute inset-0"></canvas>

    <div id="main-menu" class="absolute inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex flex-col items-center justify-center transition-opacity duration-500 z-20 font-sans antialiased">

        <h1 class="text-5xl sm:text-6xl font-black text-white mb-10 tracking-tighter drop-shadow-lg title-pulse">
            VOXEL VORTEX ARENA
        </h1>

        <div class="space-y-4 w-64 md:w-72">
            <button id="start-game" class="w-full bg-blue-600 bg-opacity-85 border-b-2 border-blue-800 hover:bg-blue-500 text-white font-extrabold py-3 px-6 uppercase rounded-md shadow-xl transform hover:scale-[1.02] transition duration-200 ease-out focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-70 text-base">
                Start Game
            </button>

            <button id="how-to-play" class="w-full bg-gray-700 bg-opacity-85 border-b-2 border-gray-900 hover:bg-gray-600 text-gray-100 font-semibold py-3 px-6 uppercase rounded-md shadow-lg transform hover:scale-[1.02] transition duration-200 ease-out focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 text-base">
                How to Play
            </button>
            <!--
            <button id="settings" class="w-full bg-gray-700 bg-opacity-85 border-b-2 border-gray-900 hover:bg-gray-600 text-gray-100 font-semibold py-3 px-6 uppercase rounded-md shadow-lg transform hover:scale-[1.02] transition duration-200 ease-out focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 text-base">
                Settings
            </button>

            <button id="quit-game" class="w-full bg-red-700 bg-opacity-85 border-b-2 border-red-900 hover:bg-red-600 text-white font-semibold py-3 px-6 uppercase rounded-md shadow-lg transform hover:scale-[1.02] transition duration-200 ease-out focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50 text-base">
                Quit Game
            </button>
                -->
        </div>
    </div>

    

    <div id="fight-button-container" class="hidden absolute top-4 right-4 z-10">
        <button id="btn-fight" class="flex items-center space-x-1 bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-full shadow-lg transition duration-200 transform hover:scale-105 shadow-xl" title="Start Battle">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path id="fight-icon-path" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19l-7-7 7-7m8 14l-7-7 7-7"></path>
            </svg>
            <span id="fight-btn-text" class="text-lg font-bold">Fight</span>
        </button>
    </div>

    <div id="game-hud" class="hidden absolute top-0 left-0 h-full p-2 sm:p-4 z-10 flex flex-col items-start">

        <div class="flex items-center space-x-2 mb-2">
            <button id="btn-collapse"
                    class="w-8 h-8 sm:w-10 sm:h-10 bg-gray-700 hover:bg-gray-600 text-white rounded-full shadow-lg transition duration-200">
                <i class="fa-solid fa-angles-left text-sm" id="collapse-icon"></i>
            </button>

            <button id="btn-fullscreen-toggle"
                    class="flex items-center justify-center space-x-1 bg-gray-700 hover:bg-gray-800 text-white font-semibold px-4 py-2 rounded-lg shadow-md transition duration-200 text-sm"
                    title="Toggle Fullscreen">
                <i class="fa-solid fa-expand text-sm" id="fullscreen-icon"></i>
                <span class="hidden sm:inline">Fullscreen</span>
            </button>
        </div>

        <div id="game-panel-content" class="flex flex-col max-w-xs sm:max-w-sm w-full h-full bg-gray-800 bg-opacity-70 rounded-xl ui-panel transition-all duration-300 overflow-hidden">

            <div id="panel-inner-wrapper" class="flex flex-col space-y-3 p-3 transition-opacity duration-200 opacity-100 pointer-events-auto">

                <div class="flex justify-start items-center pb-2 border-b border-gray-700 w-full min-w-[150px]">
                    <p id="game-status" class="text-white text-sm font-semibold min-w-[100px]">Status: Ready</p>
                </div>

                <div class="flex justify-between items-center w-full space-x-2">
                    <button id="btn-alter-terrain" class="flex flex-1 items-center justify-center space-x-1 bg-purple-600 hover:bg-purple-700 text-white px-3 py-2 text-sm rounded-lg shadow-lg transition duration-200 transform hover:scale-105" title="Generate New Terrain">
                        <i class="fa-solid fa-mountain text-sm"></i>
                        <span class="font-semibold">New Terrain</span>
                    </button>
                    <button id="btn-revert-terrain" class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-2 text-sm rounded-lg shadow-md transition duration-200 transform hover:scale-105 min-w-[90px]" title="Revert to initial plain ground">
                        <i class="fa-solid fa-retweet text-sm"></i>
                        <span>Revert</span>
                    </button>
                </div>

                <div class="flex justify-between items-center w-full space-x-2">
                    <span class="text-white text-sm font-semibold min-w-[50px]">Map:</span>
                    <button id="btn-increase-size" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white px-3 py-2 text-sm rounded-lg shadow-md transition duration-200 transform hover:scale-105" title="Increase Map Size">
                        <i class="fa-solid fa-magnifying-glass-plus"></i>
                    </button>
                    <button id="btn-decrease-size" class="flex-1 bg-teal-600 hover:bg-teal-700 text-white px-3 py-2 text-sm rounded-lg shadow-md transition duration-200 transform hover:scale-105" title="Decrease Map Size">
                        <i class="fa-solid fa-magnifying-glass-minus"></i>
                    </button>
                </div>

                <div class="flex justify-center items-center w-full space-x-2 border-b border-gray-700 pt-3 pb-2">
                    <span class="text-white text-sm font-semibold">Display:</span>
                    <button id="toggle-health" data-toggle="showHealth" class="toggle-btn bg-gray-700 text-green-400 px-3 py-1 rounded-md toggle-active text-xs" title="Toggle Health">
                        <i class="fa-solid fa-heart"></i>
                    </button>
                    <button id="toggle-name" data-toggle="showName" class="toggle-btn bg-gray-700 text-white px-3 py-1 rounded-md text-xs" title="Toggle Name">
                        <i class="fa-solid fa-tag"></i>
                    </button>
                    <button id="toggle-weapon" data-toggle="showWeapon" class="toggle-btn bg-gray-700 text-yellow-400 px-3 py-1 rounded-md text-xs" title="Toggle Weapon">
                        <i class="fa-solid fa-gun"></i>
                    </button>
                </div>

                <div class="flex justify-between items-center w-full space-x-2">
                    <button id="btn-remove-entity" class="bg-gray-600 hover:bg-yellow-600 text-white px-3 py-2 text-sm rounded-lg shadow-md transition duration-200 transform hover:scale-105 flex-1" title="Click to remove an entity">
                        <i class="fa-solid fa-eraser text-sm"></i>
                        <span>Remove</span>
                    </button>
                    <button id="btn-clear-all" class="bg-red-700 hover:bg-red-800 text-white px-3 py-2 text-sm rounded-lg shadow-md transition duration-200 transform hover:scale-105 flex-1" title="Remove all units and trees">
                        <i class="fa-solid fa-trash-can text-sm"></i>
                        <span>Clear All</span>
                    </button>
                </div>

                <div class="flex justify-between items-center w-full space-x-2">
                    <button id="btn-summon-tree" class="flex flex-1 items-center justify-center space-x-1 bg-lime-500 hover:bg-lime-600 text-white px-3 py-2 text-sm rounded-lg shadow-lg transition duration-200 transform hover:scale-105" title="Summon Tree">
                        <i class="fa-solid fa-tree text-sm"></i>
                        <span class="font-semibold">Tree/Obstacle</span>
                    </button>
                </div>

                <div class="w-full p-4 border rounded-lg bg-gray-50">
                    <div class="flex items-center justify-between mb-4">
                        <span class="text-black text-sm font-semibold whitespace-nowrap">Army Size:</span>
                        <input id="txt-soldier-count"
                               type="number"
                               placeholder="Count"
                               value="5"
                               class="w-24 px-3 py-2 border border-gray-300 rounded-lg text-gray-800 focus:outline-none focus:ring-2 focus:ring-red-500 transition duration-150 text-sm" />
                    </div>

                    <div class="flex space-x-4 mb-4">

                        <div class="flex-1 p-3 border border-red-300 rounded-lg bg-red-50 shadow-sm">
                            <h3 class="text-sm font-bold text-red-700 mb-2">Team A (Red)</h3>

                            <label for="weapon-a" class="block text-xs font-medium text-red-500 mb-1">Weapon:</label>
                            <select id="weapon-a"
                                    class="w-full px-3 py-2 text-sm border border-red-400 rounded-lg text-gray-800 focus:outline-none focus:ring-2 focus:ring-red-500 transition duration-150 mb-3">
                            </select>

                            <label for="class-a" class="block text-xs font-medium text-red-500 mb-1">Unit Tier:</label>
                            <select id="class-a"
                                    class="w-full px-3 py-2 text-sm border border-red-400 rounded-lg text-gray-800 focus:outline-none focus:ring-2 focus:ring-red-500 transition duration-150 mb-3">
                            </select>

                            <div class="flex items-center">
                                <input id="chk-team-a-disabled"
                                       type="checkbox"
                                       class="h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500">
                                <label for="chk-team-a-disabled" class="ml-2 text-sm text-red-700 font-medium">Disabled</label>
                            </div>
                        </div>

                        <div class="flex-1 p-3 border border-blue-300 rounded-lg bg-blue-50 shadow-sm">
                            <h3 class="text-sm font-bold text-blue-700 mb-2">Team B (Blue)</h3>

                            <label for="weapon-b" class="block text-xs font-medium text-blue-500 mb-1">Weapon:</label>
                            <select id="weapon-b"
                                    class="w-full px-3 py-2 text-sm border border-blue-400 rounded-lg text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-150 mb-3">
                            </select>

                            <label for="class-b" class="block text-xs font-medium text-blue-500 mb-1">Unit Class:</label>
                            <select id="class-b"
                                    class="w-full px-3 py-2 text-sm border border-blue-400 rounded-lg text-gray-800 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-150 mb-3">
                            </select>

                            <div class="flex items-center">
                                <input id="chk-team-b-disabled"
                                       type="checkbox"
                                       class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                <label for="chk-team-b-disabled" class="ml-2 text-sm text-blue-700 font-medium">Disabled</label>
                            </div>
                        </div>
                    </div>

                    <button id="btn-summon-army"
                            class="flex w-full items-center justify-center space-x-2 bg-red-600 hover:bg-red-700 text-white font-semibold px-4 py-3 rounded-lg shadow-md transition duration-200 transform hover:scale-[1.01] mt-2 text-lg"
                            title="Summon Army">
                        <i class="fa-solid fa-people-group"></i>
                        <span>Summon Army</span>
                    </button>
                </div>

                <div class="flex-grow"></div>
            </div>
        </div>
    </div>

    <div id="how-to-play-modal" class="hidden absolute inset-0 bg-gray-900 bg-opacity-70 flex items-center justify-center z-30">
        <div class="bg-white p-6 rounded-xl w-full max-w-md shadow-2xl mx-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4 text-center">How to Play</h2>

            <div class="flex flex-col items-start">
                <ul class="space-y-3 text-gray-700 text-sm sm:text-base w-full pb-12">

                    <li class="flex items-start space-x-3">
                        <i class="fa-solid fa-hand-pointer text-blue-600 mt-1 flex-shrink-0"></i>
                        <p>
                            **Interact (Click/Drag):** When not fighting, click and drag units to **reposition** them on the map.
                        </p>
                    </li>

                    <li class="flex items-start space-x-3">
                        <i class="fa-solid fa-eraser text-yellow-600 mt-1 flex-shrink-0"></i>
                        <p>
                            **Remove/Clear:** Press **Remove Entity** (Yellow button) and click a unit/tree, or use **Clear All Map** (Red button) to wipe the board.
                        </p>
                    </li>

                    <li class="flex items-start space-x-3">
                        <i class="fa-solid fa-mountain text-purple-600 mt-1 flex-shrink-0"></i>
                        <p>
                            **Terrain:** Use **New Terrain** to generate mountains or **Revert Plain** to flatten the ground. Change world size with **Map Size** controls.
                        </p>
                    </li>

                    <li class="flex items-start space-x-3">
                        <i class="fa-solid fa-person-running text-teal-600 mt-1 flex-shrink-0"></i>
                        <p>
                            **Movement/Attack:** Units have visible **walk animations** when moving and an **arm swing animation** when attacking.
                        </p>
                    </li>

                    <li class="flex items-start space-x-3">
                        <i class="fa-solid fa-toggle-on text-green-600 mt-1 flex-shrink-0"></i>
                        <p>
                            **Toggles:** Use the **HP, Name, and Wpn** buttons to show/hide unit details above their heads.
                        </p>
                    </li>
                </ul>
            </div>

            <button id="close-how-to-play" class="mt-2 w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 rounded-lg transition duration-200 sticky bottom-0">Got It</button>
        </div>
    </div>

    <script type="module">
        // ----------------------------------------------------
        // SIMPLEX NOISE IMPLEMENTATION (FOR SMOOTH TERRAIN)
        // ----------------------------------------------------
        // Self-contained, simple 2D Simplex Noise function for smooth, non-spiky terrain.
        const SimplexNoise = (function () {
            const p = new Uint8Array(256);
            for (let i = 0; i < 256; i++) p[i] = i;

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            shuffle(p);
            const perm = new Uint8Array(512);
            for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

            const grad2 = [
                [1, 1], [-1, 1], [1, -1], [-1, -1],
                [1, 0], [-1, 0], [0, 1], [0, -1]
            ];

            function dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);
            const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;

            function noise2D(xin, yin) {
                const s = (xin + yin) * F2;
                const i = Math.floor(xin + s);
                const j = Math.floor(yin + s);
                const t = (i + j) * G2;
                const X0 = i - t;
                const Y0 = j - t;
                const x0 = xin - X0;
                const y0 = yin - Y0;

                let i1, j1;
                if (x0 > y0) {
                    i1 = 1; j1 = 0;
                } else {
                    i1 = 0; j1 = 1;
                }

                const x1 = x0 - i1 + G2;
                const y1 = y0 - j1 + G2;
                const x2 = x0 - 1.0 + 2.0 * G2;
                const y2 = y0 - 1.0 + 2.0 * G2;

                const ii = i & 255;
                const jj = j & 255;
                const gi0 = perm[ii + perm[jj]] % 8;
                const gi1 = perm[ii + i1 + perm[jj + j1]] % 8;
                const gi2 = perm[ii + 1 + perm[jj + 1]] % 8;

                let n0, n1, n2;

                let t0 = 0.5 - x0 * x0 - y0 * y0;
                if (t0 < 0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * dot(grad2[gi0], x0, y0);
                }

                let t1 = 0.5 - x1 * x1 - y1 * y1;
                if (t1 < 0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * dot(grad2[gi1], x1, y1);
                }

                let t2 = 0.5 - x2 * x2 - y2 * y2;
                if (t2 < 0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * dot(grad2[gi2], x2, y2);
                }

                return 70.0 * (n0 + n1 + n2);
            }

            /**
             * Generates a noise value using Fractional Brownian Motion (FBM) / Octaves.
             */
            function fbm(x, y, octaves, lacunarity, persistence) {
                let total = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    total += noise2D(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return total / maxValue;
            }

            return {
                fbm: fbm
            };
        })();

        // ----------------------------------------------------
        // GLOBAL DEFINITIONS (UPDATED FOR DAMAGE FIX)
        // ----------------------------------------------------
        const WEAPONS = [
            // Weapon Rarity Base Damage (5 to 50)
            { name: "Dagger", damage: 20, range: 2.0, missChance: 0.1, weight: 5, icon: "üî™" },
            { name: "Sword", damage: 30, range: 3.0, missChance: 0.05, weight: 4, icon: "üó°Ô∏è" },
            { name: "Rifle", damage: 25, range: 10.0, missChance: 0.15, weight: 3, icon: "üî´" },
            { name: "Grenade Launcher", damage: 50, range: 15.0, missChance: 0.3, weight: 1, icon: "üí£" }
        ];

        const UNIT_TIERS = [
            // Character Rarity Damage Multiplier (1.0 to 1.5)
            { name: "Normal", minHp: 50, maxHp: 100, speed: 0.05, hue: 0.0, emissive: 0.0, weight: 5, colorClass: "text-black-400", damageMultiplier: 1.0 },
            { name: "Elite", minHp: 101, maxHp: 200, speed: 0.07, hue: 0.1, emissive: 0.1, weight: 3, colorClass: "text-maroon-400", damageMultiplier: 1.15 },
            { name: "Epic", minHp: 201, maxHp: 400, speed: 0.09, hue: 0.3, emissive: 0.3, weight: 2, colorClass: "text-magenta-400", damageMultiplier: 1.5 },
            { name: "Legendary", minHp: 401, maxHp: 550, speed: 0.12, hue: 0.5, emissive: 0.5, weight: 1, colorClass: "text-yellow-400", damageMultiplier: 1.75 }
        ];

        // Fight Button Icon Paths
        const FIGHT_ICON = 'M9 19l-7-7 7-7m8 14l-7-7 7-7';
        const STOP_ICON = 'M10 9l3 3m0 0l-3 3m3-3h7m-5-3v6M4 4h16a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V6a2 2 0 012-2z';
        const UNIT_FOOT_OFFSET = 0.9;

        // Terrain Variables
        let currentGroundSize = 80;
        let currentGroundSubdivisions = 60; // High subdivisions for mountain detail
        const MAX_HEIGHT = 8; // Increased max height for better mountains
        const MIN_SIZE = 20;
        const MAX_SIZE = 80;
        const SIZE_STEP = 10;
        let initialTerrainData = null; // Store the initial plain terrain height map
        let currentTerrainComplexity = 0.2; // Track current complexity (0.2 is plain, 1.0 is mountainous)


        let battleLoopInterval = null;
        let currentDraggingUnit = null;
        let isRemoving = false; // State for remove mode

        // Global Display Toggles for GUI (UPDATED: Only show health on initial load)
        let displayToggles = {
            showName: false,
            showHealth: true,
            showWeapon: false
        };

        // Helper to choose item based on weight
        function weightedRandom(items) {
            const totalWeight = items.reduce((sum, item) => sum + item.weight, 0);
            let randomNum = Math.random() * totalWeight;
            for (const item of items) {
                if (randomNum < item.weight) {
                    return item;
                }
                randomNum -= item.weight;
            }
        }

        // ----------------------------------------------------
        // TERRAIN GENERATION LOGIC (UPDATED FOR SMOOTH MOUNTAINS with Simplex Noise)
        // ----------------------------------------------------

        /**
         * Generates an array of heights for the ground vertices using Simplex Noise FBM.
         * This creates smooth, realistic rolling hills/mountains.
         * @param {number} complexity - Max height factor (0.2 for plain, 1.0 for mountainous).
         * @returns {number[]} Array of height values.
         */
        function generateTerrainData(complexity = 1.0) {
            const heightMap = [];
            const subdivisions = currentGroundSubdivisions;
            const size = currentGroundSize;
            const maxHeight = MAX_HEIGHT * complexity;

            // FBM (Fractal Brownian Motion) parameters for realistic mountain detail
            const OCTAVES = 5;
            const LACUNARITY = 2.0; // Frequency multiplier
            const PERSISTENCE = 0.5; // Amplitude multiplier
            const SCALE = 0.05; // Zoom level - smaller number is more zoomed in/larger features

            for (let i = 0; i <= subdivisions; i++) {
                for (let j = 0; j <= subdivisions; j++) {
                    // Convert grid coordinate (i, j) to world coordinate (x, z)
                    const x = (i / subdivisions) * size - (size / 2);
                    const z = (j / subdivisions) * size - (size / 2);

                    // 1. Generate multi-octave noise (result is between -1 and 1)
                    let noiseValue = SimplexNoise.fbm(
                        x * SCALE,
                        z * SCALE,
                        OCTAVES,
                        LACUNARITY,
                        PERSISTENCE
                    );

                    // Map noise from [-1, 1] to [0, maxHeight] (positive height map)
                    let height = (noiseValue + 1) * 0.5 * maxHeight;

                    // 2. Apply edge-fading factor (Reduce height towards map edges)
                    const centerDistX = Math.abs(x);
                    const centerDistZ = Math.abs(z);
                    const maxCenterDist = size / 2;
                    // Factor decreases from 1 (center) to 0.1 (edges)
                    const edgeFactor = 1 - (Math.max(centerDistX, centerDistZ) / maxCenterDist) * 0.9;
                    height *= edgeFactor;

                    // Add a tiny base height to ensure terrain is not below 0 at complexity=0.2
                    height = Math.max(0.01 * size * complexity, height);

                    heightMap.push(height);
                }
            }
            return heightMap;
        }

        // Applies the height data to the ground mesh
        function applyTerrainToGround(heightData) {
            const positions = ground.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            const totalVertices = (currentGroundSubdivisions + 1) * (currentGroundSubdivisions + 1);

            if (positions.length / 3 !== totalVertices || heightData.length !== totalVertices) {
                console.error("Vertex count mismatch for terrain application. Subdivisions might be mismatched.");
                return;
            }

            // Positions are (x, y, z) triplets. Update the y-coordinate (index + 1)
            for (let i = 0; i < totalVertices; i++) {
                positions[i * 3 + 1] = heightData[i];
            }

            ground.setVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
            // Recalculate normals after height change for correct lighting
            ground.createNormals(true);
        }

        // Adjust all existing entities (units and trees) to sit on the new ground level
        // Adjust all existing entities (units and trees) to sit on the new ground level
        function adjustEntitiesToNewGround() {
            const entitiesToAdjust = [
                ...units.filter(u => u.isAlive).map(u => u.rootNode),
                ...scene.meshes.filter(m => m.name === "Tree")
            ];

            const pickFilter = (mesh) => mesh === ground;

            entitiesToAdjust.forEach(entity => {
                const ray = new BABYLON.Ray(entity.position.add(new BABYLON.Vector3(0, 10, 0)), BABYLON.Vector3.Down());
                const pick = scene.pickWithRay(ray, pickFilter);

                if (pick.hit) {
                    let baseOffset;

                    if (entity.name.includes("unitRoot")) {
                        // FIX: Offset root node up by 0.9 so the feet (at Y=-0.9) land on the ground
                        baseOffset = UNIT_FOOT_OFFSET;
                    } else if (entity.name === "Tree") {
                        // Tree center is at Y=1, so we offset by 1
                        baseOffset = 1;
                    }

                    entity.position.y = pick.pickedPoint.y + baseOffset;
                }
            });
        }

        // Main function to create new random, mountainous terrain
        function generateNewTerrain() {
            // Generate a high complexity, mountainous terrain
            currentTerrainComplexity = 1.0;
            const mountainData = generateTerrainData(currentTerrainComplexity);
            applyTerrainToGround(mountainData);

            adjustEntitiesToNewGround();

            $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-purple-400">Terrain altered!</span>');
            setTimeout(() => updateGameStatus(), 1500);
        }

        // Revert to initial plain field
        function revertGroundTerrain() {
            if (initialTerrainData) {
                currentTerrainComplexity = 0.2; // Reset complexity
                applyTerrainToGround(initialTerrainData);

                adjustEntitiesToNewGround();

                $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-green-400">Terrain reverted to plain.</span>');
                setTimeout(() => updateGameStatus(), 1500);
            }
        }

        function updateGroundSize(change) {
            const newSize = Math.max(MIN_SIZE, Math.min(MAX_SIZE, currentGroundSize + change));

            if (newSize === currentGroundSize) {
                $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-yellow-400">Cannot change size further.</span>');
                setTimeout(() => updateGameStatus(), 1500);
                return;
            }

            currentGroundSize = newSize;

            // 1. Recreate the ground mesh with the new size
            ground = createGroundMesh(currentGroundSize, currentGroundSubdivisions);

            // 2. Generate and apply new terrain (keeping the current complexity)
            const newTerrainData = generateTerrainData(currentTerrainComplexity);
            applyTerrainToGround(newTerrainData);

            // 3. If the terrain is plain, update the initial data; otherwise, save a new plain version for 'Revert'
            initialTerrainData = generateTerrainData(0.2);

            // 4. Adjust all entities to the new height/surface
            adjustEntitiesToNewGround();

            $('#game-status').html(`<span class="text-xs sm:text-lg font-extrabold text-teal-400">Map size updated to ${currentGroundSize}x${currentGroundSize}.</span>`);
            setTimeout(() => updateGameStatus(), 1500);
        }


        // ----------------------------------------------------
        // BABYLON.JS SETUP
        // ----------------------------------------------------
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);
        let scene, camera, ground, advancedTexture;
        let units = [];
        let unitCount = 0;
        let selectedTeam = 'A';

        function createGroundMesh(size, subdivisions) {
            if (ground) {
                // Dispose old ground mesh before creating a new one
                ground.dispose();
            }
            const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.2);

            const newGround = BABYLON.MeshBuilder.CreateGround("ground", { width: size, height: size, subdivisions: subdivisions }, scene);
            newGround.material = groundMaterial;
            newGround.receiveShadows = true;
            return newGround;
        }

        const createScene = function () {
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.5, 0.8, 0.9);

            camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 4, 30, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            camera.lowerRadiusLimit = 10;
            camera.upperRadiusLimit = 60;
            camera.wheelPrecision = 50;
            camera.inputs.remove(camera.inputs.attached.mousewheel);
            camera.inputs.addMouseWheel();

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
            light.intensity = 0.8;

            // 1. Create initial ground mesh
            ground = createGroundMesh(currentGroundSize, currentGroundSubdivisions);

            // 2. Apply initial, gentle (plain) terrain (complexity 0.2)
            currentTerrainComplexity = 0.2;
            const plainData = generateTerrainData(currentTerrainComplexity);
            applyTerrainToGround(plainData);
            initialTerrainData = plainData; // Save the plain data

            advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);

            setupPointerObservables(); // Initialize drag and remove logic

            $('#game-hud').hide();
            $('#fight-button-container').hide(); // Hide fight button initially
            $('#main-menu').show();

            return scene;
        };

        const scene_instance = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                const deltaTime = engine.getDeltaTime() / 1000;
                scene.render();

                // --- MOVEMENT & ANIMATION LOGIC ---
                units.filter(u => u.isAlive).forEach(unit => {
                    unit.updateAnimation(deltaTime);

                    if (unit.state === 'moving') {
                        if (unit.target && unit.target.isAlive) {
                            const targetPos = unit.target.mesh.position;
                            const reached = unit.moveTowardsTarget({ x: targetPos.x, z: targetPos.z }, deltaTime);
                            if (reached) {
                                unit.state = 'attacking';
                            }
                        } else {
                            unit.state = 'idle';
                            unit.target = null;
                        }
                    }
                });
            }
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });


        // ----------------------------------------------------
        // POINTER OBSERVABLES (Click/Drag/Remove)
        // ----------------------------------------------------

        function setupPointerObservables() {
            scene.onPointerObservable.add((pointerInfo) => {
                const pickInfo = pointerInfo.pickInfo;
                const pickedUnit = pickInfo?.hit ? (pickInfo.pickedMesh.parent?.unitData || pickInfo.pickedMesh.unitData) : null;

                switch (pointerInfo.type) {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                        if (isRemoving) {
                            if (pickedUnit) {
                                pickedUnit.die();
                            } else if (pickInfo.hit && pickInfo.pickedMesh.name.includes("Tree")) {
                                pickInfo.pickedMesh.dispose();
                            }
                            // Reset mode after one action or a click
                            isRemoving = false;
                            $('#btn-remove-entity').removeClass('bg-yellow-500 toggle-active').addClass('bg-gray-600').html('Remove Entity');
                            $('#game-status').html('Status: Ready');
                            return;
                        }

                        if (pickedUnit && !battleLoopInterval) {
                            // Start Drag
                            currentDraggingUnit = pickedUnit;
                            camera.detachControl(canvas);
                        }
                        break;

                    case BABYLON.PointerEventTypes.POINTERUP:
                        if (currentDraggingUnit) {
                            // End Drag
                            currentDraggingUnit = null;
                            camera.attachControl(canvas, true);
                        }
                        break;

                    case BABYLON.PointerEventTypes.POINTERMOVE:
                        if (currentDraggingUnit) {
                            // Dragging logic
                            const ray = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), camera, false);
                            const groundPick = scene.pickWithRay(ray, (mesh) => mesh === ground);

                            if (groundPick.hit) {
                                currentDraggingUnit.rootNode.position.x = groundPick.pickedPoint.x;
                                currentDraggingUnit.rootNode.position.z = groundPick.pickedPoint.z;
                                currentDraggingUnit.rootNode.position.y = groundPick.pickedPoint.y + UNIT_FOOT_OFFSET;
                            }
                        }
                        break;
                }
            });
        }


        // ----------------------------------------------------
        // GAME ENTITY FUNCTIONS & CLASS (UPDATED FOR DAMAGE FIX & TIER SELECTION)
        // ----------------------------------------------------

        class GameUnit {
            // UPDATED: Accept tierData and weaponData
            constructor(name, team, position, tierData, weaponData, scene) {
                this.id = unitCount++;
                this.name = name;
                this.team = team;
                this.isAlive = true;

                // Use provided data
                this.tierData = tierData; // <--- ADDED: Fixes damageMultiplier error
                this.tier = tierData.name;
                this.tierColorClass = tierData.colorClass;
                this.weapon = weaponData;
                this.maxLife = Math.floor(Math.random() * (tierData.maxHp - tierData.minHp + 1)) + tierData.minHp;
                this.life = this.maxLife;
                this.speed = tierData.speed;
                // this.damage = this.weapon.damage; // REMOVED: Damage calculated on attack

                this.state = 'idle';
                this.target = null;
                this.attackCooldown = 0;
                this.walkCycle = 0; // for walk animation

                this.rootNode = new BABYLON.TransformNode(`unitRoot_${this.id}`, scene);
                // Position will be set via raycast immediately after creation
                this.rootNode.position = new BABYLON.Vector3(position.x, 0, position.z);
                this.rootNode.unitData = this; // Link root node to unit data

                this.mesh = this.rootNode;

                const baseColor = team === 'A' ? BABYLON.Color3.Red() : BABYLON.Color3.Blue();
                const colorHue = baseColor.scale(1 - tierData.hue).add(BABYLON.Color3.White().scale(tierData.hue));

                this.buildVoxelHuman(colorHue, tierData.emissive);

                // Store the original material for the damage flash effect to revert to
                this.originalMaterial = this.torso.material;

                this.label = this.createLabel();
                updateUnitLabelsVisibility(); // Apply initial display settings
            }

            /**
             * NOTE ON MODEL IMPROVEMENT:
             * To render a human dummy/weapon that looks much better,
             * you should replace the voxel mesh construction below with a GLTF/GLB model load.
             * * 1. Comment out the `buildVoxelHuman` call in the constructor.
             * 2. Use BABYLON.SceneLoader.ImportMeshAsync to load a GLTF file:
             * * BABYLON.SceneLoader.ImportMeshAsync("", "path/to/model/", "unit.glb", scene).then((result) => {
             * // result.meshes[0] will be the root of the imported model.
             * result.meshes[0].parent = this.rootNode;
             * * // You would then modify the animation functions (updateAnimation, attack)
             * // to use the imported model's animation groups (result.animationGroups).
             * });
             */

            createWeaponMesh() {
                let weaponMesh;
                const s = 0.5; // Use the unit scale 's' from the main function for better consistency

                // Material for all weapons (Gold/Brass color)
                const wMat = new BABYLON.StandardMaterial("wMat", scene);
                wMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.3); // Brass/Gold tone for hilt

                // Material for the blade/barrel (Silver/Gunmetal color)
                const bladeMat = new BABYLON.StandardMaterial("bladeMat", scene);
                bladeMat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); // Silver/Metal tone for blade

                // Helper function to combine and parent meshes
                const combineMeshes = (name, parts) => {
                    const root = new BABYLON.Mesh(name + "_root", scene);
                    parts.forEach(part => {
                        part.parent = root;
                    });
                    return root;
                };

                switch (this.weapon.name) {
                    case "Dagger":
                        // üó°Ô∏è Components: Blade (Cone for tip), Mid-Blade (Cylinder), Crossguard (Box), Handle (Cylinder)

                        const daggerBladeLength = s * 0.8;
                        const daggerBladeRadius = s * 0.06;
                        const handleLength = s * 0.4;

                        // Blade Tip (Cone)
                        const daggerTip = BABYLON.MeshBuilder.CreateCylinder("daggerTip", { height: daggerBladeLength / 3, diameterTop: 0, diameterBottom: daggerBladeRadius * 2, tessellation: 6 }, scene);
                        daggerTip.material = bladeMat;
                        daggerTip.position.y = daggerBladeLength * 0.8;

                        // Blade Body (Cylinder)
                        const daggerMid = BABYLON.MeshBuilder.CreateCylinder("daggerMid", { height: daggerBladeLength * 2 / 3, diameter: daggerBladeRadius * 2, tessellation: 6 }, scene);
                        daggerMid.material = bladeMat;
                        daggerMid.position.y = daggerBladeLength * 0.35;

                        // Crossguard (Thin Box)
                        const daggerGuard = BABYLON.MeshBuilder.CreateBox("daggerGuard", { height: s * 0.05, width: s * 0.3, depth: s * 0.08 }, scene);
                        daggerGuard.material = wMat;
                        daggerGuard.position.y = -s * 0.1; // Positioned between blade and handle

                        // Handle (Cylinder)
                        const daggerHandle = BABYLON.MeshBuilder.CreateCylinder("daggerHandle", { height: handleLength, diameter: s * 0.12 }, scene);
                        daggerHandle.material = wMat;
                        daggerHandle.position.y = -s * 0.2; // Below the guard

                        weaponMesh = combineMeshes("Dagger", [daggerTip, daggerMid, daggerGuard, daggerHandle]);
                        break;

                    case "Sword":
                        // Components: Blade (box) + Crossguard (box) + Hilt (cylinder)
                        const swordBlade = BABYLON.MeshBuilder.CreateBox("swordBlade", { height: s * 3.0, width: s * 0.2, depth: s * 0.05 }, scene);
                        swordBlade.material = bladeMat;
                        swordBlade.position.y = s * 1.5;

                        const swordGuard = BABYLON.MeshBuilder.CreateBox("swordGuard", { height: s * 0.1, width: s * 0.5, depth: s * 0.1 }, scene);
                        swordGuard.material = wMat;
                        swordGuard.position.y = 0;

                        const swordHandle = BABYLON.MeshBuilder.CreateCylinder("swordHandle", { height: s * 1.0, diameter: s * 0.15 }, scene);
                        swordHandle.material = wMat;
                        swordHandle.position.y = -s * 0.5;

                        weaponMesh = combineMeshes("Sword", [swordBlade, swordGuard, swordHandle]);
                        break;

                    case "Rifle":
                        // Components: Body (long box) + Barrel (thin cylinder) + Stock (small box)
                        const rifleBody = BABYLON.MeshBuilder.CreateBox("rifleBody", { height: s * 0.3, width: s * 0.2, depth: s * 1.5 }, scene);
                        rifleBody.material = wMat;
                        rifleBody.position.z = s * 0.25;

                        const rifleBarrel = BABYLON.MeshBuilder.CreateCylinder("rifleBarrel", { height: s * 2.0, diameter: s * 0.08 }, scene);
                        rifleBarrel.material = bladeMat;
                        // Rotate and position the barrel along the Z-axis (forward)
                        rifleBarrel.rotation.x = Math.PI / 2;
                        rifleBarrel.position.z = s * 0.75;
                        rifleBarrel.position.y = s * 0.1;

                        const rifleStock = BABYLON.MeshBuilder.CreateBox("rifleStock", { height: s * 0.5, width: s * 0.3, depth: s * 0.5 }, scene);
                        rifleStock.material = wMat;
                        rifleStock.position.z = -s * 0.8;
                        rifleStock.position.y = -s * 0.1;

                        weaponMesh = combineMeshes("Rifle", [rifleBody, rifleBarrel, rifleStock]);
                        break;

                    case "Grenade Launcher":
                        // Components: Large Barrel (cylinder) + Handle (small box) + Sight (small box)
                        const glBarrel = BABYLON.MeshBuilder.CreateCylinder("glBarrel", { height: s * 2.5, diameter: s * 0.35 }, scene);
                        glBarrel.material = bladeMat;
                        glBarrel.rotation.x = Math.PI / 2; // Orient along Z-axis (forward)
                        glBarrel.position.z = s * 0.1;

                        const glHandle = BABYLON.MeshBuilder.CreateBox("glHandle", { height: s * 0.8, width: s * 0.2, depth: s * 0.2 }, scene);
                        glHandle.material = wMat;
                        glHandle.position.z = -s * 0.5;
                        glHandle.position.y = -s * 0.4; // Hanging down

                        const glSight = BABYLON.MeshBuilder.CreateBox("glSight", { size: s * 0.1, depth: s * 0.5 }, scene);
                        glSight.material = wMat;
                        glSight.position.z = s * 0.5;
                        glSight.position.y = s * 0.2;

                        weaponMesh = combineMeshes("GrenadeLauncher", [glBarrel, glHandle, glSight]);
                        break;

                    default:
                        // Default (Unarmed/Fist)
                        weaponMesh = BABYLON.MeshBuilder.CreateBox("fist", { size: s * 0.2 }, scene);
                        weaponMesh.material = wMat;
                }

                return weaponMesh;
            }

            buildVoxelHuman(color, emissiveMultiplier) {
                const s = 0.5; // Base scale factor
                const material = new BABYLON.StandardMaterial(`mat_${this.id}`, scene);
                material.diffuseColor = color;
                material.emissiveColor = color.scale(emissiveMultiplier * 0.3);

                // --- Core Dimensions ---
                const stickRadius = s * 0.15;
                const torsoRadius = s * 0.5;
                const torsoHeight = s * 1.5;
                const limbSegmentHeight = s * 0.9;
                const armXOffset = torsoRadius + stickRadius / 2;
                const armYOffset = s * 0.8;
                const legSeparation = torsoRadius;

                // --- Weapon Data Retrieval & Posing Constants ---
                // Assuming global WEAPONS array is accessible
                const DAGGER_ITEM = WEAPONS.find(w => w.name === "Dagger");
                const MELEE_FORWARD_ROTATION_X = Math.PI / 2; // 90 degrees for downward-held weapons
                const RANGED_ARM_FORWARD_ROTATION_X = -Math.PI / 2; // -90 degrees to point arms straight out (forward)

                // --- Torso & Head (UNCHANGED) ---
                this.torso = BABYLON.MeshBuilder.CreateCylinder("torso", { height: torsoHeight, diameter: torsoRadius * 2 }, scene);
                this.torso.position = new BABYLON.Vector3(0, torsoHeight / 2, 0);
                this.torso.material = material;
                this.torso.parent = this.rootNode;
                this.torso.unitData = this;

                const headRadius = s * 0.6;
                this.head = BABYLON.MeshBuilder.CreateSphere("head", { diameter: headRadius * 2 }, scene);
                this.head.position = new BABYLON.Vector3(0, torsoHeight / 2 + headRadius, 0);
                this.head.material = material;
                this.head.parent = this.torso;

                // --------------------------------------------------------
                // --- Legs (Segmented: Upper, Knee, Lower) ---
                // --------------------------------------------------------

                // LEFT LEG
                this.legLeftRoot = new BABYLON.TransformNode("legLRoot", scene);
                this.legLeftRoot.parent = this.torso;
                this.legLeftRoot.position = new BABYLON.Vector3(-legSeparation / 2, -torsoHeight / 2, 0);
                this.legLeftUpper = BABYLON.MeshBuilder.CreateCylinder("legLU", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.legLeftUpper.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legLeftUpper.material = material;
                this.legLeftUpper.parent = this.legLeftRoot;
                this.legLeftKnee = new BABYLON.TransformNode("legLKnee", scene);
                this.legLeftKnee.parent = this.legLeftUpper;
                this.legLeftKnee.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legLeftLower = BABYLON.MeshBuilder.CreateCylinder("legLL", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.legLeftLower.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legLeftLower.material = material;
                this.legLeftLower.parent = this.legLeftKnee;

                // RIGHT LEG
                this.legRightRoot = new BABYLON.TransformNode("legRRoot", scene);
                this.legRightRoot.parent = this.torso;
                this.legRightRoot.position = new BABYLON.Vector3(legSeparation / 2, -torsoHeight / 2, 0);
                this.legRightUpper = BABYLON.MeshBuilder.CreateCylinder("legRU", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.legRightUpper.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legRightUpper.material = material;
                this.legRightUpper.parent = this.legRightRoot;
                this.legRightKnee = new BABYLON.TransformNode("legRKnee", scene);
                this.legRightKnee.parent = this.legRightUpper;
                this.legRightKnee.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legRightLower = BABYLON.MeshBuilder.CreateCylinder("legRL", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.legRightLower.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.legRightLower.material = material;
                this.legRightLower.parent = this.legRightKnee;


                // --------------------------------------------------------
                // --- Arms (Segmented: Upper, Elbow, Lower) ---
                // --------------------------------------------------------

                // RIGHT ARM
                this.armRightRoot = new BABYLON.TransformNode("armRRoot", scene);
                this.armRightRoot.parent = this.torso;
                this.armRightRoot.position = new BABYLON.Vector3(armXOffset, armYOffset, 0);
                this.armRightUpper = BABYLON.MeshBuilder.CreateCylinder("armRU", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.armRightUpper.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armRightUpper.material = material;
                this.armRightUpper.parent = this.armRightRoot;
                this.armRightElbow = new BABYLON.TransformNode("armRElbow", scene);
                this.armRightElbow.parent = this.armRightUpper;
                this.armRightElbow.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armRightLower = BABYLON.MeshBuilder.CreateCylinder("armRL", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.armRightLower.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armRightLower.material = material;
                this.armRightLower.parent = this.armRightElbow;

                // LEFT ARM
                this.armLeftRoot = new BABYLON.TransformNode("armLRoot", scene);
                this.armLeftRoot.parent = this.torso;
                this.armLeftRoot.position = new BABYLON.Vector3(-armXOffset, armYOffset, 0);
                this.armLeftUpper = BABYLON.MeshBuilder.CreateCylinder("armLU", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.armLeftUpper.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armLeftUpper.material = material;
                this.armLeftUpper.parent = this.armLeftRoot;
                this.armLeftElbow = new BABYLON.TransformNode("armLElbow", scene);
                this.armLeftElbow.parent = this.armLeftUpper;
                this.armLeftElbow.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armLeftLower = BABYLON.MeshBuilder.CreateCylinder("armLL", { height: limbSegmentHeight, diameter: stickRadius * 2 }, scene);
                this.armLeftLower.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armLeftLower.material = material;
                this.armLeftLower.parent = this.armLeftElbow;


                // --------------------------------------------------------
                // --- Weapon Attachment and Poses (Dynamic) ---
                // --------------------------------------------------------

                // Hand Nodes
                this.armRightHand = new BABYLON.TransformNode("armRHand", scene);
                this.armRightHand.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armRightHand.parent = this.armRightLower;

                this.armLeftHand = new BABYLON.TransformNode("armLHand", scene);
                this.armLeftHand.position = new BABYLON.Vector3(0, -limbSegmentHeight / 2, 0);
                this.armLeftHand.parent = this.armLeftLower;

                // --- Weapon Meshes ---
                this.weaponMesh = this.createWeaponMesh(this.weapon); // Main weapon
                this.weaponMesh.parent = this.armRightHand;

                if (DAGGER_ITEM) {
                    this.daggerMesh = this.createWeaponMesh(DAGGER_ITEM); // Dagger (secondary)
                } else {
                    // Fallback for dagger
                    this.daggerMesh = BABYLON.MeshBuilder.CreateBox("missingDagger", { size: 0.01 }, scene);
                }
                this.daggerMesh.parent = this.armLeftHand;


                // --- Set Poses based on Weapon Range (Melee vs. Ranged) ---

                if (this.weapon.range > 5) {
                    // RANGED WEAPONS (Rifle, Grenade Launcher) - Held forward

                    // Arm Root (Shoulder) Rotation: Swing arms 90 degrees forward
                    this.armRightRoot.rotation.x = RANGED_ARM_FORWARD_ROTATION_X;
                    this.armLeftRoot.rotation.x = RANGED_ARM_FORWARD_ROTATION_X;

                    // Weapon Mesh Rotation (Relative to hand): No rotation needed if arms are straight out
                    this.weaponMesh.rotation.x = 0;
                    this.weaponMesh.rotation.z = 0;
                    this.weaponMesh.position = new BABYLON.Vector3(0.3, 0.1, 0); // Offset for two-handed look

                    // Left arm takes a placeholder mesh and stays in position
                    this.daggerMesh.dispose(); // Remove dagger if unit is using a two-handed weapon
                    this.daggerMesh = BABYLON.MeshBuilder.CreateBox("empty", { size: 0.01 }, scene);
                    this.daggerMesh.parent = this.armLeftHand;

                    // Elbow rotation for aiming comfort
                    this.armRightElbow.rotation.x = Math.PI / 18; // Slight bend forward
                    this.armLeftElbow.rotation.x = Math.PI / 18; // Match the bend

                } else {
                    // MELEE WEAPONS (Sword, Dagger) - Hands pointing downward, weapons forward

                    // Arm Root (Shoulder) Rotation: Hands pointing downward, arms straight
                    this.armRightRoot.rotation.x = 0;
                    this.armLeftRoot.rotation.x = 0;

                    // Weapon Mesh Rotation: Rotate 90 degrees forward relative to the hand
                    this.weaponMesh.rotation.x = MELEE_FORWARD_ROTATION_X;
                    this.weaponMesh.rotation.z = Math.PI / 12; // Outward tilt
                    this.weaponMesh.position = new BABYLON.Vector3(0, 0, 0.1);

                    // Left Weapon (Dagger)
                    this.daggerMesh.rotation.x = MELEE_FORWARD_ROTATION_X;
                    this.daggerMesh.rotation.z = -Math.PI / 12; // Outward tilt
                    this.daggerMesh.position = new BABYLON.Vector3(0, 0, 0.1);

                    // Ensure elbows are straight
                    this.armRightElbow.rotation.x = 0;
                    this.armLeftElbow.rotation.x = 0;
                }
            }


            createLabel() {
                const labelContainer = new BABYLON.GUI.StackPanel();
                labelContainer.height = "100px";
                labelContainer.width = "200px";

                const nameText = new BABYLON.GUI.TextBlock();
                nameText.color = this.tierColorClass.replace('text-', '').replace('-400', '');
                nameText.fontSize = 16;
                nameText.height = "25px";
                nameText.outlineWidth = 0;
                nameText.outlineColor = "black";
                this.nameText = nameText;
                labelContainer.addControl(nameText);

                const lifeText = new BABYLON.GUI.TextBlock();
                lifeText.color = "lime";
                lifeText.fontSize = 12;
                lifeText.height = "25px";
                lifeText.outlineWidth = 1;
                lifeText.outlineColor = "black";
                this.lifeText = lifeText;
                labelContainer.addControl(lifeText);

                advancedTexture.addControl(labelContainer);
                labelContainer.linkWithMesh(this.rootNode);
                labelContainer.linkOffsetY = -65;
                return labelContainer;
            }

            updateAnimation(deltaTime) {
                // Walk Animation (Leg and Arm Swing)
                if (this.isAlive && this.state === 'moving') {
                    // Increment the walk cycle phase
                    this.walkCycle += deltaTime * 5;

                    // Calculate the main swing rotation (e.g., amplitude 0.5 radians ‚âà 28.6 degrees)
                    const swing = Math.sin(this.walkCycle) * 0.5;

                    // --- LEG SWING ---
                    // Left leg forward, Right leg backward
                    this.legLeftRoot.rotation.x = swing;
                    this.legRightRoot.rotation.x = -swing;

                    // --- ARM SWING (Opposite to legs) ---
                    // Right arm swings forward when the right leg swings back (-swing)
                    this.armRightRoot.rotation.x = swing;
                    // Left arm swings backward when the left leg swings forward (swing)
                    this.armLeftRoot.rotation.x = -swing;

                    // --- JOINT BENDING (Optional: Adds realism) ---
                    // Calculate a positive bend based on the absolute value of the swing (max bend at max swing)
                    const bend = Math.abs(swing) * 0.4;

                    // Knees: Bend backward
                    this.legLeftKnee.rotation.x = bend;
                    this.legRightKnee.rotation.x = bend;

                    // Elbows: Bend slightly inward/upward (negative rotation)
                    this.armLeftElbow.rotation.x = -bend;
                    this.armRightElbow.rotation.x = -bend;

                } else {
                    // Reset to standing pose when not moving
                    this.legLeftRoot.rotation.x = 0;
                    this.legRightRoot.rotation.x = 0;
                    this.armLeftRoot.rotation.x = 0;
                    this.armRightRoot.rotation.x = 0;

                    // Ensure knees and elbows are straight
                    if (this.legLeftKnee) this.legLeftKnee.rotation.x = 0;
                    if (this.legRightKnee) this.legRightKnee.rotation.x = 0;
                    if (this.armLeftElbow) this.armLeftElbow.rotation.x = 0;
                    if (this.armRightElbow) this.armRightElbow.rotation.x = 0;
                }
            }


            moveTowardsTarget(targetPosition, deltaTime) {
                if (this.rootNode.isDisposed()) return false;

                const currentPos = this.rootNode.position;
                // Calculate the target vector without using the current Y position (for rotation/distance calculation)
                const targetVectorXZ = new BABYLON.Vector3(targetPosition.x, currentPos.y, targetPosition.z);

                // Rotation: Face the target
                this.rootNode.lookAt(targetVectorXZ);

                const distance = BABYLON.Vector3.Distance(currentPos, targetVectorXZ);

                if (distance <= this.weapon.range * 0.9) {
                    // Stop within range
                    return true;
                }

                const direction = targetVectorXZ.subtract(currentPos).normalize();
                const step = direction.scale(this.speed * deltaTime * 60);

                // 1. Apply X and Z movement first
                this.rootNode.position.x += step.x;
                this.rootNode.position.z += step.z;

                // 2. FIX: Raycast downwards from the new X, Z position to find the ground height
                const rayOrigin = this.rootNode.position.add(new BABYLON.Vector3(0, 10, 0));
                const ray = new BABYLON.Ray(rayOrigin, BABYLON.Vector3.Down());

                // Assuming 'ground' mesh is globally accessible
                const pick = scene.pickWithRay(ray, (mesh) => mesh === ground);

                if (pick.hit) {
                    const groundHeight = pick.pickedPoint.y;

                    // Use the defined constant UNIT_FOOT_OFFSET (which should be 0.9)
                    // to place the unit's feet exactly on the ground.
                    this.rootNode.position.y = groundHeight + UNIT_FOOT_OFFSET;
                }
                // If the ray doesn't hit the ground (e.g., unit is above a hole/canyon),
                // it will maintain its current Y position, or you could add falling logic here.

                return false;
            }

            // New: Visual feedback when unit takes damage (red flash)
            flashMesh() {
                // Use the unit's material property which was saved in the constructor
                const originalMat = this.originalMaterial;

                // Create a temporary red material for the flash effect
                const flashMaterial = new BABYLON.StandardMaterial("flashMat", scene);
                flashMaterial.diffuseColor = BABYLON.Color3.Red();
                flashMaterial.emissiveColor = BABYLON.Color3.Red().scale(0.5);

                // List of all primary meshes
                const meshesToFlash = [this.torso, this.head, this.legLeft, this.legRight, this.armRight, this.armLeft];

                // Apply flash material
                meshesToFlash.forEach(mesh => {
                    if (mesh && mesh.material) mesh.material = flashMaterial;
                });

                // Revert after a short delay (100ms)
                setTimeout(() => {
                    if (!this.rootNode.isDisposed()) {
                        meshesToFlash.forEach(mesh => {
                            if (mesh) mesh.material = originalMat;
                        });
                    }
                }, 100);
            }

            // New: Encapsulate the arm swinging logic
            animateAttack() {
                // If it's a voxel unit with arms, animate the arm swing
                if (this.armRightRoot) {
                    // Swing angle calculation
                    const swingAngle = this.weapon.range < 5 ? Math.PI / 3 : -Math.PI / 8;

                    // Animate arm rotation for attack pattern (Swing Out)
                    BABYLON.Animation.CreateAndStartAnimation(
                        "attackAnim",
                        this.armRightRoot,
                        "rotation.x",
                        30, // frame rate
                        10, // total frames
                        0, // start value
                        swingAngle, // end value (swing out)
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                        new BABYLON.CubicEase()
                    ).onAnimationEnd = () => {
                        // Return arm to original pose (Ready pose = 0)
                        BABYLON.Animation.CreateAndStartAnimation(
                            "returnAnim",
                            this.armRightRoot,
                            "rotation.x",
                            30,
                            10,
                            swingAngle,
                            0,
                            BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                        );
                    };
                }
            }

            // UPDATED: Damage calculation uses the new formula (Weapon * Rarity)
            attack(target) {
                // FIX: Check if the enemy unit (target) is alive, not the enemy's target.
                if (!target || !target.isAlive || this.rootNode.isDisposed()) {
                    this.state = 'idle';
                    this.target = null;
                    return;
                }

                // Miss chance
                if (Math.random() < this.weapon.missChance) {
                    this.nameText.text = "MISS!";
                    this.nameText.color = "yellow";
                    setTimeout(() => {
                        if (this.nameText && !this.nameText.isDisposed) {
                            updateUnitLabelsVisibility();
                        }
                    }, 500);
                    // Stop attacking state if miss
                    this.state = 'idle';
                    return;
                }

                // New Damage Calculation: (Weapon Base Damage: 5-50) * (Character Rarity Multiplier: 1.0-1.5)
                const baseDamage = this.weapon.damage;
                const rarityMultiplier = this.tierData.damageMultiplier;
                const finalDamage = Math.round(baseDamage * rarityMultiplier); // Round for clean integer damage

                // Trigger damage and visual feedback
                target.updateLife(finalDamage);

                // Encapsulate animation logic
                this.animateAttack();
            }

            updateLife(damage) {
                this.life -= damage;
                this.life = Math.max(0, this.life);

                // New: Flash unit on hit
                if (damage > 0) {
                    this.flashMesh();
                }

                this.lifeText.text = `HP: ${this.life}/${this.maxLife}`;

                if (this.life / this.maxLife < 0.3) {
                    this.lifeText.color = "red";
                }

                if (this.life <= 0) {
                    this.die();
                }
            }

            die() {
                this.isAlive = false;
                this.rootNode.dispose();
                if (this.label) {
                    this.label.dispose();
                }
                updateGameStatus();
            }
        }

        // Helper to update all unit labels based on global display settings
        function updateUnitLabelsVisibility() {
            units.filter(u => u.isAlive).forEach(unit => {
                // Visibility Toggles
                unit.nameText.isVisible = displayToggles.showName || displayToggles.showWeapon;
                unit.lifeText.isVisible = displayToggles.showHealth;

                // Content Update
                let nameContent = "";
                if (displayToggles.showWeapon) nameContent += unit.weapon.icon + " ";
                if (displayToggles.showName) nameContent += unit.name + " ";
                // Always show tier if name is shown
                unit.nameText.text = nameContent.trim() + (displayToggles.showName ? ` (${unit.tier})` : "");
            });
        }

        function createTree(position) {
            const trunk = BABYLON.MeshBuilder.CreateBox("trunk", { height: 2, width: 0.5, depth: 0.5 }, scene);
            const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
            trunkMat.diffuseColor = new BABYLON.Color3(0.5, 0.3, 0.1);
            trunk.material = trunkMat;
            trunk.name = "Tree";

            const leaves = BABYLON.MeshBuilder.CreateBox("leaves", { height: 1.5, width: 1.5, depth: 1.5 }, scene);
            leaves.position.y = 1.5; // Offset from trunk center
            const leavesMat = new BABYLON.StandardMaterial("leavesMat", scene);
            leavesMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
            leaves.material = leavesMat;
            leaves.name = "Tree";

            const tree = BABYLON.Mesh.MergeMeshes([trunk, leaves], true, true, undefined, false, true);
            tree.name = "Tree";

            // Raycast to place tree on ground
            const ray = new BABYLON.Ray(new BABYLON.Vector3(position.x, 10, position.z), BABYLON.Vector3.Down());
            const pick = scene.pickWithRay(ray, (mesh) => mesh === ground);

            if (pick.hit) {
                // Tree position is (0, 1, 0) relative to its base. So we add 1 to the picked point Y.
                tree.position = new BABYLON.Vector3(position.x, pick.pickedPoint.y + 1, position.z);
            } else {
                tree.position = new BABYLON.Vector3(position.x, 1, position.z);
            }

            return tree;
        }

        // UPDATED: Added selectedTierName parameter
        function spawnCharacter(team, selectedTierName = 'random') {

            const mapRadius = currentGroundSize / 2;
            const spawnRange = mapRadius * 0.75; // Spawn units within 75% of the radius
            let x = Math.random() * (currentGroundSize * 0.75) - (currentGroundSize * 0.375);
            let z = Math.random() * (currentGroundSize * 0.75) - (currentGroundSize * 0.375);

            if (team == 'A') {
                x = spawnRange / 2 + Math.random() * (spawnRange / 2);
                z = -spawnRange + Math.random() * (spawnRange / 2);
            } else if (team == 'B') {
                x = -spawnRange + Math.random() * (spawnRange / 2);
                z = spawnRange / 2 + Math.random() * (spawnRange / 2);
            }

            const position = { x: x, z: z };

            let tierData;
            if (selectedTierName === 'random') {
                tierData = weightedRandom(UNIT_TIERS);
            } else {
                tierData = UNIT_TIERS.find(t => t.name === selectedTierName);
                if (!tierData) { // Fallback just in case
                    console.error(`Tier ${selectedTierName} not found. Defaulting to random.`);
                    tierData = weightedRandom(UNIT_TIERS);
                }
            }

            const weaponData = weightedRandom(WEAPONS);
            const name = `Unit ${team}-${unitCount}`;

            // Create unit with selected/randomized tier and weapon
            // UPDATED: Pass tierData and weaponData
            const newUnit = new GameUnit(name, team, position, tierData, weaponData, scene);

            // Raycast to place unit on ground
            const ray = new BABYLON.Ray(new BABYLON.Vector3(position.x, 10, position.z), BABYLON.Vector3.Down());
            const pick = scene.pickWithRay(ray, (mesh) => mesh === ground);

            if (pick.hit) {
                newUnit.rootNode.position.y = pick.pickedPoint.y;
            }

            units.push(newUnit);
            updateGameStatus();
        }

        function spawnTree() {
            const x = Math.random() * (currentGroundSize * 0.8) - (currentGroundSize * 0.4);
            const z = Math.random() * (currentGroundSize * 0.8) - (currentGroundSize * 0.4);
            const position = { x: x, z: z };
            createTree(position);
        }

        // NEW: Function to clear all units and obstacles
        function clearAllEntities() {
            if (battleLoopInterval) {
                // Stop Battle if running
                clearInterval(battleLoopInterval);
                battleLoopInterval = null;
                // Update fight button text
                $('#btn-fight').removeClass('bg-yellow-500').addClass('bg-red-500');
                $('#fight-icon-path').attr('d', FIGHT_ICON);
                $('#fight-btn-text').text('Fight');
            }

            // Dispose all units
            units.forEach(u => u.die());
            units = []; // Reset unit array

            // Dispose all trees/obstacles
            scene.meshes.filter(m => m.name === "Tree").forEach(tree => tree.dispose());

            updateGameStatus();
            $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-red-400">All entities cleared from map.</span>');
            setTimeout(() => updateGameStatus(), 1500);
        }


        // UPDATED: Added logic to revert fight button text on game over
        function updateGameStatus() {
            const aliveA = units.filter(u => u.team === 'A' && u.isAlive).length;
            const aliveB = units.filter(u => u.team === 'B' && u.isAlive).length;
            const total = aliveA + aliveB;

            $('#game-status').html(`A: <span class="text-team-a font-bold">${aliveA}</span> | B: <span class="text-team-b font-bold">${aliveB}</span> (Total: ${total})`);

            if (total > 0 && (aliveA === 0 || aliveB === 0)) {
                const winner = aliveA > 0 ? 'Team A (Red)' : 'Team B (Blue)';
                $('#game-status').html(`<span class="text-xs sm:text-xl font-extrabold text-yellow-400">GAME OVER! ${winner} WINS!</span>`);
                $('#btn-fight').prop('disabled', true).removeClass('bg-red-500 hover:bg-red-600').addClass('bg-gray-500');
                if (battleLoopInterval) { clearInterval(battleLoopInterval); battleLoopInterval = null; }
                $('#fight-icon-path').attr('d', FIGHT_ICON); // Revert to Fight icon
                $('#fight-btn-text').text('Fight'); // Revert text to Fight
            } else if (total === 0) {
                $('#game-status').html(`<span class="text-xs sm:text-xl font-extrabold text-yellow-400">All Units Eliminated!</span>`);
                $('#btn-fight').prop('disabled', true).removeClass('bg-red-500 hover:bg-red-600').addClass('bg-gray-500');
                if (battleLoopInterval) { clearInterval(battleLoopInterval); battleLoopInterval = null; }
                $('#fight-icon-path').attr('d', FIGHT_ICON); // Revert to Fight icon
                $('#fight-btn-text').text('Fight'); // Revert text to Fight
            } else if (!battleLoopInterval) {
                $('#game-status').html('Status: Ready');
                $('#btn-fight').prop('disabled', false).removeClass('bg-gray-500').addClass('bg-red-500 hover:bg-red-600');
            }
        }

        function startFight() {
            if (battleLoopInterval) {
                clearInterval(battleLoopInterval);
                battleLoopInterval = null;
            }

            battleLoopInterval = setInterval(() => {
                const currentAliveUnits = units.filter(u => u.isAlive);
                const aliveA = currentAliveUnits.filter(u => u.team === 'A');
                const aliveB = currentAliveUnits.filter(u => u.team === 'B');

                if (aliveA.length === 0 || aliveB.length === 0) {
                    clearInterval(battleLoopInterval);
                    battleLoopInterval = null;
                    updateGameStatus();
                    return;
                }

                currentAliveUnits.forEach(unit => {
                    const enemies = unit.team === 'A' ? aliveB : aliveA;

                    if (!unit.target || !unit.target.isAlive) {
                        unit.target = findNearestEnemy(unit, enemies);
                        if (unit.target) {
                            unit.state = 'moving';
                        } else {
                            unit.state = 'idle';
                        }
                    }

                    if (unit.target && unit.target.isAlive) {
                        const targetPosition = unit.target.mesh.position;
                        const distance = BABYLON.Vector3.Distance(unit.mesh.position, targetPosition);

                        if (distance <= unit.weapon.range) {
                            unit.state = 'attacking';
                            if (unit.attackCooldown <= 0) {
                                unit.attack(unit.target);
                                unit.attackCooldown = 20;
                            }
                        } else if (unit.state !== 'moving') {
                            unit.state = 'moving';
                        }
                    }

                    if (unit.attackCooldown > 0) {
                        unit.attackCooldown--;
                    }
                });

            }, 100);
        }

        function findNearestEnemy(attacker, enemies) {
            let nearestEnemy = null;
            let minDistance = Infinity;

            for (const enemy of enemies) {
                if (enemy.isAlive) {
                    const distance = BABYLON.Vector3.Distance(attacker.mesh.position, enemy.mesh.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestEnemy = enemy;
                    }
                }
            }
            return nearestEnemy;
        }

        function getTierStats(tierValue) {
            if (tierValue === 'random') {
                return 'RANDOM'; // Special indicator for random selection
            }

            // Convert value back to a searchable name (e.g., 'elite' -> 'Elite')
            const searchableName = tierValue.charAt(0).toUpperCase() + tierValue.slice(1);

            const tier = UNIT_TIERS.find(t => t.name === searchableName);
            return tier || null;
        }

        function spawnEntityAt(x, z, type, team = 'A', selectedWeaponData = null, selectedTierData = null) {
            const position = { x: x, z: z };

            // 1. Raycast to find the ground height at the position
            const ray = new BABYLON.Ray(new BABYLON.Vector3(position.x, MAX_HEIGHT + 5, position.z), BABYLON.Vector3.Down());
            const pick = scene.pickWithRay(ray, (mesh) => mesh === ground);

            let groundY = 0;
            if (pick.hit) {
                groundY = pick.pickedPoint.y;
            }

            if (type === 'unit') {

                // 2. Determine the Unit Tier (Class)
                let tierData;

                if (selectedTierData === 'RANDOM' || selectedTierData === null) {
                    // If 'Random' was selected in the UI, or no data was passed, use weighted random
                    tierData = weightedRandom(UNIT_TIERS);
                } else {
                    // Use the specific tier data passed from the UI
                    tierData = selectedTierData;
                }

                // 3. Determine the Weapon
                let weaponData;

                if (selectedWeaponData === 'RANDOM' || selectedWeaponData === null) {
                    // If 'Random' was selected in the UI, or no data was passed, use weighted random
                    weaponData = weightedRandom(WEAPONS);
                } else {
                    // Use the specific weapon data passed from the UI
                    weaponData = selectedWeaponData;
                }

                const name = `Unit ${team}-${unitCount}`;

                const newUnit = new GameUnit(name, team, position, tierData, weaponData, scene);
                newUnit.rootNode.position.y = groundY + UNIT_FOOT_OFFSET; // Set Y to ground height

                units.push(newUnit);
                unitCount++;
                updateGameStatus();

            } else if (type === 'tree') {
                // ... (Tree creation logic remains the same)
                const trunk = BABYLON.MeshBuilder.CreateBox("trunk", { height: 2, width: 0.5, depth: 0.5 }, scene);
                const trunkMat = new BABYLON.StandardMaterial("trunkMat", scene);
                trunkMat.diffuseColor = new BABYLON.Color3(0.5, 0.3, 0.1);
                trunk.material = trunkMat;
                trunk.name = "Tree";

                const leaves = BABYLON.MeshBuilder.CreateBox("leaves", { height: 1.5, width: 1.5, depth: 1.5 }, scene);
                leaves.position.y = 1.5;
                const leavesMat = new BABYLON.StandardMaterial("leavesMat", scene);
                leavesMat.diffuseColor = new BABYLON.Color3(0.2, 0.8, 0.2);
                leaves.material = leavesMat;
                leaves.name = "Tree";

                const tree = BABYLON.Mesh.MergeMeshes([trunk, leaves], true, true, undefined, false, true);
                tree.name = "Tree";
                // Tree position is (0, 1, 0) relative to its base. So we add 1 to the picked point Y.
                tree.position = new BABYLON.Vector3(x, groundY + 1, z);
            }
        }

        function getWeaponStats(weaponValue) {
            if (weaponValue === 'random') {
                return 'RANDOM'; // Special indicator for random selection
            }

            // Convert value back to a searchable name (e.g., 'grenade-launcher' -> 'Grenade Launcher')
            const searchableName = weaponValue.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');

            const weapon = WEAPONS.find(w => w.name === searchableName);

            // Note: If you used the icon and damage in the option text before, you can simplify the lookup
            // by comparing the value property directly (e.g., checking if w.name.toLowerCase() === weaponValue).
            return weapon || null;
        }

        function setupInitialMap() {
            // 1. Retrieve Selected Weapon Data
            const selectedValueA = $('#weapon-a').val();
            const selectedValueB = $('#weapon-b').val();

            // 2. Retrieve Selected Class/Tier Data (NEW)
            const selectedClassA = $('#class-a').val();
            const selectedClassB = $('#class-b').val();
            const teamATierData = getTierStats(selectedClassA);
            const teamBTierData = getTierStats(selectedClassB);

            // getWeaponStats returns the object or the string 'RANDOM'
            const teamAWeaponData = getWeaponStats(selectedValueA);
            const teamBWeaponData = getWeaponStats(selectedValueB);

            // Define map quadrants based on currentGroundSize (e.g., 40)
            const mapRadius = currentGroundSize / 2;
            const spawnRange = mapRadius * 0.75; // Spawn units within 75% of the radius

            let armySizeString = $('#txt-soldier-count').val();
            let armySize = (armySizeString !== '' && !isNaN(armySizeString))
                ? parseInt(armySizeString, 10)
                : 5;


            // --- Spawn 5 Trees (Randomly across the central 80% of the map) ---
            /*const treeSpawnRange = currentGroundSize * 0.4; // 80% of 40 is 32. Range from -16 to 16.
            for (let i = 0; i < 5; i++) {
                const x = Math.random() * (treeSpawnRange * 2) - treeSpawnRange;
                const z = Math.random() * (treeSpawnRange * 2) - treeSpawnRange;
                spawnEntityAt(x, z, 'tree');
            }*/

            // --- Team B (Blue) - Upper Left Quadrant (Negative X, Positive Z) ---
            if (!$('#chk-team-b-disabled').is(':checked')) {
                for (let i = 0; i < armySize; i++) {
                    const x = -spawnRange + Math.random() * (spawnRange / 2);
                    const z = spawnRange / 2 + Math.random() * (spawnRange / 2);

                    // PASS TEAM B WEAPON DATA AND TIER DATA
                    spawnEntityAt(x, z, 'unit', 'B', teamBWeaponData, teamBTierData);
                }
            } else {
                console.log("Team B spawning skipped: Disabled checkbox is checked.");
            }

            // --- Team A (Red) - Lower Right Quadrant (Positive X, Negative Z) ---
            if (!$('#chk-team-a-disabled').is(':checked')) {
                for (let i = 0; i < armySize; i++) {
                    const x = spawnRange / 2 + Math.random() * (spawnRange / 2);
                    const z = -spawnRange + Math.random() * (spawnRange / 2);

                    // PASS TEAM A WEAPON DATA AND TIER DATA
                    spawnEntityAt(x, z, 'unit', 'A', teamAWeaponData, teamATierData);
                }
            } else {
                console.log("Team A spawning skipped: Disabled checkbox is checked.");
            }

            $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-white">Initial setup complete!</span>');
            // Re-center camera a bit after spawning
            camera.setTarget(BABYLON.Vector3.Zero());
            camera.alpha = 0.5;
        }

        function populateWeaponDropdown(selector) {
            const $select = $(selector);

            // 1. Clear any existing options
            $select.empty();

            // 2. Add the "Random" option first
            $select.append(
                $('<option>', {
                    value: 'random',
                    text: 'Random',
                    selected: true // Make 'Random' the default selection
                })
            );

            // 3. Add options from the WEAPONS array
            $.each(WEAPONS, function (index, weapon) {
                // Use the weapon name (lowercased) as the value
                const weaponValue = weapon.name.toLowerCase().replace(/\s/g, '-');

                $select.append(
                    $('<option>', {
                        value: weaponValue,
                        text: `${weapon.icon} ${weapon.name}`
                    })
                );
            });
        }

        function populateClassDropdown(selector) {
            const $select = $(selector);

            // 1. Clear existing options
            $select.empty();

            // 2. Add the "Random" option first
            $select.append(
                $('<option>', {
                    value: 'random',
                    text: 'Random',
                    selected: true // Make 'Random' the default selection
                })
            );

            // 3. Add all tiers from the UNIT_TIERS array
            $.each(UNIT_TIERS, function (index, tier) {
                // Use the tier name (lowercased) as the value
                const tierValue = tier.name.toLowerCase();

                $select.append(
                    $('<option>', {
                        value: tierValue,
                        text: `${tier.name}`
                    })
                );
            });
        }

        // ----------------------------------------------------
        // JQUERY UI CONTROLS
        // ----------------------------------------------------
        $(document).ready(function () {

            // --- Menu Handlers ---
            $('#start-game').on('click', function () {
                setupInitialMap();

                $('#main-menu').fadeOut(500, function () {
                    $('#game-hud').fadeIn(500);
                    $('#fight-button-container').fadeIn(500);
                    updateGameStatus();
                });
            });

            $('#how-to-play').on('click', function () {
                $('#how-to-play-modal').fadeIn(300);
            });

            $('#close-how-to-play').on('click', function () {
                $('#how-to-play-modal').fadeOut(300);
            });

            // --- NEW: Populate Unit Selection Dropdown and Set Initial Toggles ---
            /*const $unitSelect = $('#unit-selection');
            $unitSelect.append('<option value="random">Random Unit (Weighted)</option>');
            UNIT_TIERS.forEach(tier => {
                $unitSelect.append(`<option value="${tier.name}">${tier.name} Rarity</option>`);
            });*/

            // Set initial toggle state: Only Health active
            $('#toggle-name').removeClass('toggle-active');
            $('#toggle-weapon').removeClass('toggle-active');
            // --- END NEW ---

            $('#btn-fullscreen-toggle').on('click', function () {
                const docElm = document.documentElement;
                const icon = $('#fullscreen-icon');

                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    // Currently in fullscreen, exit it
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    } else if (document.mozCancelFullScreen) { // Firefox
                        document.mozCancelFullScreen();
                    } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera
                        document.webkitExitFullscreen();
                    } else if (document.msExitFullscreen) { // IE/Edge
                        document.msExitFullscreen();
                    }
                } else {
                    // Not in fullscreen, enter it
                    if (docElm.requestFullscreen) {
                        docElm.requestFullscreen();
                    } else if (docElm.mozRequestFullScreen) { // Firefox
                        docElm.mozRequestFullScreen();
                    } else if (docElm.webkitRequestFullscreen) { // Chrome, Safari, Opera
                        docElm.webkitRequestFullscreen();
                    } else if (docElm.msRequestFullscreen) { // IE/Edge
                        docElm.msRequestFullscreen();
                    }
                }
            });

            // --- Update button icon when fullscreen state changes ---
            $(document).on('fullscreenchange webkitfullscreenchange mozfullscreenchange MSFullscreenChange', function () {
                const icon = $('#fullscreen-icon');
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    // In fullscreen: Change icon to 'minimize' (contract)
                    icon.removeClass('fa-expand').addClass('fa-compress');
                } else {
                    // Not in fullscreen: Change icon to 'expand'
                    icon.removeClass('fa-compress').addClass('fa-expand');
                }
            });

            // --- HUD Handlers ---
            $('.team-btn').on('click', function () {
                selectedTeam = $(this).data('team');
                $('.team-btn').removeClass('bg-team-a bg-team-b').addClass('bg-gray-600');
                $(this).removeClass('bg-gray-600').addClass(selectedTeam === 'A' ? 'bg-team-a' : 'bg-team-b');
            });

            /*$('#btn-summon-character').on('click', function () {
                if (battleLoopInterval) {
                    $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-red-500">Battle in progress! Cannot summon.</span>');
                    setTimeout(() => updateGameStatus(), 1500);
                    return;
                }
                const selectedTier = $('#unit-selection').val(); // Get selected tier from dropdown
                spawnCharacter(selectedTeam, selectedTier);
            });*/

            $('#btn-summon-tree').on('click', function () {
                spawnTree();
            });

            $('#btn-summon-army').on('click', function () {
                //clearAllEntities();
                setupInitialMap();
            });

            // Terrain Handlers
            $('#btn-alter-terrain').on('click', function () {
                generateNewTerrain();
            });
            $('#btn-revert-terrain').on('click', function () {
                revertGroundTerrain();
            });
            $('#btn-increase-size').on('click', function () {
                updateGroundSize(SIZE_STEP);
            });
            $('#btn-decrease-size').on('click', function () {
                updateGroundSize(-SIZE_STEP);
            });

            // Toggle Button Handlers
            $('.toggle-btn').on('click', function () {
                const key = $(this).data('toggle');
                displayToggles[key] = !displayToggles[key];
                $(this).toggleClass('toggle-active', displayToggles[key]);
                updateUnitLabelsVisibility();
            });

            // Remove Entity Handler
            $('#btn-remove-entity').on('click', function () {
                if (isRemoving) {
                    // Turn off remove mode
                    isRemoving = false;
                    $(this).removeClass('bg-yellow-500 toggle-active').addClass('bg-gray-600').text('Remove Entity');
                    $('#game-status').html('Status: Ready');
                } else {
                    // Turn on remove mode
                    isRemoving = true;
                    $(this).removeClass('bg-gray-600').addClass('bg-yellow-500 toggle-active').text('CLICK TO REMOVE');
                    $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-yellow-400">REMOVE MODE ACTIVE! Click entity.</span>');
                }
                // Disabling fight mode if active
                if (battleLoopInterval) {
                    $('#btn-fight').click();
                }
            });

            // NEW: Clear All Handler
            $('#btn-clear-all').on('click', function () {
                clearAllEntities();
            });

            // Fight Button Handler (Now on the floating button)
            $('#btn-fight').on('click', function () {
                const aliveA = units.filter(u => u.team === 'A' && u.isAlive).length;
                const aliveB = units.filter(u => u.team === 'B' && u.isAlive).length;

                if (aliveA === 0 || aliveB === 0) {
                    $('#game-status').html('<span class="text-xs sm:text-lg font-extrabold text-red-500">Need units on both teams to fight!</span>');
                    setTimeout(() => updateGameStatus(), 1500);
                    return;
                }
                if (battleLoopInterval) {
                    // Stop Battle
                    clearInterval(battleLoopInterval);
                    battleLoopInterval = null;
                    units.forEach(u => u.state = 'idle');
                    updateGameStatus();

                    $(this).removeClass('bg-yellow-500').addClass('bg-red-500');
                    $('#fight-icon-path').attr('d', FIGHT_ICON);
                    $('#fight-btn-text').text('Fight');

                } else {
                    // Start Battle
                    startFight();

                    $('#game-status').html('<span class="text-xs sm:text-xl font-extrabold text-red-500">BATTLE IN PROGRESS!</span>');

                    $(this).removeClass('bg-red-500').addClass('bg-yellow-500');
                    $('#fight-icon-path').attr('d', STOP_ICON);
                    $('#fight-btn-text').text('Stop');
                }
            });

            // --- Collapse/Expand Logic ---
            let isPanelCollapsed = false;

            $('#btn-collapse').on('click', function () {
                isPanelCollapsed = !isPanelCollapsed;
                const $panelContent = $('#game-panel-content');
                const $innerWrapper = $('#panel-inner-wrapper');
                const $collapseIconPath = $('#collapse-icon-path');

                if (isPanelCollapsed) {
                    // Collapse: start fading inner content, then collapse width
                    $innerWrapper.removeClass('opacity-100 pointer-events-auto').addClass('opacity-0 pointer-events-none');
                    // Delay width collapse slightly for better visual effect, or rely on transition duration
                    setTimeout(() => {
                        $panelContent.removeClass('max-w-xs sm:max-w-sm');
                        $panelContent.addClass('max-w-0');
                    }, 50);

                    // Change icon to 'open' arrow (pointing right)
                    $collapseIconPath.attr('d', 'M13 5l7 7-7 7m-8-14l7 7-7 7');
                } else {
                    // Expand: expand width first, then fade in inner content
                    $panelContent.removeClass('max-w-0');
                    $panelContent.addClass('max-w-xs sm:max-w-sm');

                    // Fade in inner content after the width transition has started (200ms duration total for opacity)
                    setTimeout(() => {
                        $innerWrapper.removeClass('opacity-0 pointer-events-none').addClass('opacity-100 pointer-events-auto');
                    }, 100);

                    // Change icon to 'close' arrow (pointing left)
                    $collapseIconPath.attr('d', 'M11 19l-7-7 7-7m8 14l-7-7 7-7');
                }
            });

            populateWeaponDropdown('#weapon-a');
            populateWeaponDropdown('#weapon-b');

            populateClassDropdown('#class-a');
            populateClassDropdown('#class-b');
        });
    </script>
</body>
</html>