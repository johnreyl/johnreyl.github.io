<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Typing Madness</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Custom Fonts */
        .font-press-start {
            font-family: 'Press Start 2P', cursive;
        }

        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }

        /* General Body and Game Container */
        body {
            background-color: #0d1117;
            color: #ffffff;
            overflow: hidden;
        }

        #game-container {
            /* Ensures game container scales nicely on small screens */
            width: 100%;
            height: 100%;
            max-width: 4xl;
            max-height: 800px;
            background: radial-gradient(circle at center, rgba(16, 24, 39, 0.9) 0%, rgba(13, 17, 23, 0.95) 100%), url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect x="0" y="0" width="100" height="100" fill="%230d1117"/><circle cx="50" cy="50" r="10" fill="%231a2c42" opacity="0.3"/><circle cx="50" cy="50" r="5" fill="%232c4a70" opacity="0.2"/><path d="M0 0 L100 0 L100 100 L100 100 L0 100 Z" fill="none" stroke="%231a2c42" stroke-width="1"/></svg>') repeat;
            background-size: cover;
        }

        /* Title Specifics */
        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            text-shadow: 0 0 15px rgba(59, 130, 246, 0.7), 0 0 30px rgba(59, 130, 246, 0.4);
        }

        /* Custom Button Styling (Skewed, Glowing) */
        .menu-btn {
            background: linear-gradient(145deg, #1e3a8a, #2563eb);
            border: 2px solid #3b82f6;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), 0 0 10px rgba(59, 130, 246, 0.5);
            transition: all 0.2s ease-in-out;
            transform: skew(-10deg);
            text-align: center;
        }

            .menu-btn:hover {
                background: linear-gradient(145deg, #2563eb, #3b82f6);
                transform: skew(-10deg) scale(1.05);
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), 0 0 15px rgba(59, 130, 246, 0.8);
            }

            .menu-btn span {
                display: inline-block;
                transform: skew(10deg); /* Counter-skew text */
            }

        .menu-btn-secondary {
            background: linear-gradient(145deg, #374151, #4b5563);
            border: 2px solid #6b7280;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), 0 0 8px rgba(107, 114, 128, 0.3);
        }

            .menu-btn-secondary:hover {
                background: linear-gradient(145deg, #4b5563, #6b7280);
                box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3), 0 0 12px rgba(107, 114, 128, 0.5);
            }

        /* Popups Styling (Centered with fixed position and transform) */
        .popup-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(16, 24, 39, 0.98);
            border: 2px solid #3b82f6;
            border-radius: 1rem;
            box-shadow: 0 0 30px rgba(59, 130, 246, 0.6);
            z-index: 100;
            padding: 1.5rem; /* Reduced padding for mobile */
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Game Over Modal Styling */
        #game-over-screen.popup-panel {
            z-index: 200;
            background-color: rgba(13, 17, 23, 0.99);
            border-color: #ef4444;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
        }

        /* History Table Styling */
        #history-table th, #history-table td {
            padding: 0.25rem 0.5rem;
            text-align: left;
            white-space: nowrap; /* Prevent wrapping in table cells */
        }

        #history-table th {
            color: #93c5fd; /* Blue-300 */
            border-bottom: 1px solid #1f2937; /* Gray-800 */
            font-size: 0.6rem; /* Very small font for header */
        }

        #history-table td {
            font-size: 0.65rem; /* Small font for data */
        }

        #history-table tr:nth-child(even) {
            background-color: #111827; /* Darker row for contrast */
        }


        /* Typing Input */
        #typing-input {
            position: absolute;
            opacity: 0;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            cursor: default;
        }

        /* Bubbles */
        .bubble {
            position: absolute;
            width: 45px; /* Slightly smaller for mobile */
            height: 45px;
            border-radius: 50%;
            background-color: rgba(59, 130, 246, 0.8); /* Default Blue (Letters) */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem; /* Smaller pixel font */
            font-weight: bold;
            color: white;
            border: 2px solid rgba(147, 197, 253, 0.9);
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
            top: -60px;
            transition: transform 0.1s, opacity 0.1s;
            user-select: none;
            font-family: 'Press Start 2P', cursive;
        }

        /* Type Specific Bubble Colors */
        .bubble-number {
            background-color: rgba(239, 68, 68, 0.8); /* Red-500 */
            border: 2px solid rgba(252, 165, 165, 0.9); /* Red-300 */
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .bubble-symbol {
            background-color: rgba(168, 85, 247, 0.8); /* Purple-500 */
            border: 2px solid rgba(221, 214, 254, 0.9); /* Purple-300 */
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
        }

        .bubble-word {
            width: auto;
            min-width: 70px;
            padding: 4px 8px; /* Reduced padding */
            height: 35px; /* Reduced height */
            font-size: 1rem; /* Smaller Orbitron font */
            background-color: rgba(168, 85, 247, 0.8);
            border: 2px solid rgba(196, 181, 253, 0.9);
            box-shadow: 0 0 10px rgba(168, 85, 247, 0.5);
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }

        /* Heart Bubble Styling */
        .bubble-heart {
            background-color: rgba(239, 68, 68, 0.9); /* Bright Red */
            border: 3px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.8), inset 0 0 5px rgba(255, 255, 255, 0.5);
            font-size: 1.5rem; /* Larger emoji */
            width: 60px;
            height: 60px;
            z-index: 55;
            animation: pulse 1s infinite; /* Make it noticeable */
        }

        /* --- TURRET STYLING CHANGES --- */
        /* Turret Assembly Container */
        #turret-assembly {
            position: absolute;
            bottom: 4px; /* Slightly adjusted to align with main turret base original position */
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
        }

        /* Main Turret Base Styling (Removed positioning, now flex item) */
        #turret-base {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 50px;
            height: auto;
            transition: none;
            position: relative;
        }

        /* Mini Turret Styling */
        .mini-turret {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 30px; /* Width of the mini turret body */
            height: 40px;
            position: relative;
        }

        /* NEW Mini Turret Body/Display */
        .mini-turret-display {
            position: relative;
            width: 30px; /* Smaller than main (40px) */
            height: 30px;
            background-color: #4b5563; /* Gray-600 */
            border: 2px solid #9ca3af; /* Gray-400 */
            color: white;
            font-size: 0.75rem;
            font-family: 'Press Start 2P', cursive;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px 10px 0 0;
            box-shadow: 0 0 5px #4b5563;
            z-index: 2;
        }

        .mini-gun-nozzle {
            position: relative;
            width: 4px;
            height: 30px; /* Half size */
            background-color: #374151; /* Gray-700 */
            border: 1px solid #6b7280; /* Gray-500 */
            border-radius: 1px 1px 0 0;
            margin-bottom: -15px; /* Connects nozzle to the top of the 30px body */
            transform-origin: bottom center;
            transition: transform 0.15s ease-out;
            transform: rotate(0deg);
            z-index: 1;
        }

        /* Mini Projectile Styling */
        .mini-projectile {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #f59e0b; /* Amber/Orange projectile */
            border-radius: 50%;
            box-shadow: 0 0 6px #fcd34d;
            z-index: 60;
        }
        /* --- END TURRET STYLING CHANGES --- */


        /* Character Display (Smaller) */
        #turret-display {
            position: relative;
            width: 40px;
            height: 40px;
            background-color: #2563eb; /* Blue-600 */
            border: 3px solid #60a5fa; /* Blue-400 */
            color: white;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 14px 14px 0 0;
            box-shadow: 0 0 10px #3b82f6;
            margin-top: 0; /* Connects directly to nozzle */
            z-index: 2;
        }

        /* Gun Nozzle (Turret Look) */
        #turret-gun-nozzle {
            position: relative;
            width: 8px; /* Barrel width */
            height: 40px; /* LONGER BARREL */
            background-color: #374151; /* Gray-700 */
            border: 2px solid #6b7280; /* Gray-500 */
            border-radius: 2px 2px 0 0;
            margin-bottom: -20px;
            /* Turret Rotation Setup */
            transform-origin: bottom center;
            transition: transform 0.15s ease-out; /* Smooth rotation */
            transform: rotate(0deg); /* Start vertical */
            z-index: 1;
        }

        /* Projectile Styling (Main) */
        #projectile {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #ef4444; /* Red projectile */
            border-radius: 50%;
            box-shadow: 0 0 8px #f87171;
            z-index: 60;
        }

        /* Animations (Retained) */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .animate-pulse-effect {
            animation: pulse 1.5s infinite;
        }

        @keyframes heartbeat {
            0%, 100% {
                transform: scale(1);
            }

            15% {
                transform: scale(1.1);
            }

            30% {
                transform: scale(1);
            }

            45% {
                transform: scale(1.1);
            }
        }

        .heartbeat-animation {
            animation: heartbeat 1s ease-in-out;
        }

        /* --- UPDATED: Softer and Slower Flash --- */
        @keyframes incorrect-flash {
            0% {
                background-color: transparent;
            }

            50% {
                /* Softer orange color at a low 20% opacity */
                background-color: rgba(255, 165, 0, 0.2);
            }

            100% {
                background-color: transparent;
            }
        }

        .incorrect-flash-bg {
            /* Slower duration for a gentle fade instead of a rapid flash */
            animation: incorrect-flash 0.7s ease-out;
        }
        /* --- END UPDATED STYLES --- */


        /* NEW TURRET EXPLOSION STYLES */
        #turret-explosion-container {
            /* Span the area of the turret display/nozzle for centering */
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 80px; /* To cover both nozzle and display */
            pointer-events: none;
            overflow: hidden;
            z-index: 5;
        }

        .explosion-circle {
            position: absolute;
            width: 0px;
            height: 0px;
            border-radius: 50%;
            background-color: rgba(255, 140, 0, 1); /* Initial bright orange */
            transform: translate(-50%, -50%); /* Center the circle */
            top: 60px; /* Adjust to center around the display/pivot area */
            left: 50%;
            z-index: 10;
            pointer-events: none;
            animation: explosion-pulse 0.5s ease-out forwards;
        }

        @keyframes explosion-pulse {
            0% {
                width: 0px;
                height: 0px;
                opacity: 1;
                box-shadow: 0 0 10px 5px rgba(255, 165, 0, 0.8), 0 0 20px 10px rgba(239, 68, 68, 0.6);
            }

            100% {
                width: 100px; /* Max size */
                height: 100px;
                opacity: 0;
                box-shadow: 0 0 50px 20px rgba(255, 165, 0, 0); /* Glow fades */
            }
        }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center font-orbitron">

    <div id="game-container" class="relative w-full h-full max-w-4xl max-h-[800px] shadow-2xl p-4 overflow-hidden rounded-lg">

        <div id="main-menu" class="absolute inset-0 flex flex-col items-center justify-center p-8 z-20 transition-opacity duration-500 bg-gray-900/90">
            <h1 class="text-4xl sm:text-6xl font-extrabold mb-8 sm:mb-12 text-blue-400 tracking-wider game-title">TYPING MADNESS</h1>
            <div class="space-y-3 sm:space-y-4 w-56 sm:w-64">
                <button id="start-game-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn"><span>START GAME</span></button>
                <button id="settings-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn menu-btn-secondary"><span>SETTINGS</span></button>
                <button id="fullscreen-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn menu-btn-secondary"><span>FULL SCREEN</span></button>
                <button id="history-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn menu-btn-secondary"><span>HISTORY</span></button>
            </div>
        </div>

        <div id="game-mode-popup" class="hidden popup-panel w-full max-w-sm sm:max-w-3xl">
            <h2 class="text-2xl sm:text-3xl font-bold mb-4 sm:mb-6 text-center text-blue-300 game-title">SELECT GAME MODE</h2>
            <div class="flex flex-col sm:flex-row gap-4 sm:gap-6">
                <div id="mode-bubble" class="mode-card flex-1 p-4 sm:p-6 border-blue-500 rounded-xl hover:bg-gray-600 cursor-pointer transition duration-300 transform hover:scale-[1.02] shadow-lg">
                    <h3 class="text-xl sm:text-2xl font-bold mb-1 sm:mb-2 text-center game-title">BUBBLE BURST</h3>
                    <p class="text-gray-300 text-center mb-3 sm:mb-4 text-xs font-press-start">Pop single-character bubbles (Letters, Numbers, Symbols). 5 Lives.</p>
                    <button class="select-mode-btn w-full py-2 bg-blue-600 hover:bg-blue-700 rounded-lg text-sm font-semibold font-press-start" data-mode="bubble">SELECT</button>
                </div>
                <div id="mode-word" class="mode-card flex-1 p-4 sm:p-6 border-purple-500 rounded-xl hover:bg-gray-600 cursor-pointer transition duration-300 transform hover:scale-[1.02] shadow-lg">
                    <h3 class="text-xl sm:text-2xl font-bold mb-1 sm:mb-2 text-center game-title">WORD FALL</h3>
                    <p class="text-gray-300 text-center mb-3 sm:mb-4 text-xs font-press-start">Type full words. 2 min. timer per level.</p>
                    <button class="select-mode-btn w-full py-2 bg-purple-600 hover:bg-purple-700 rounded-lg text-sm font-semibold font-press-start" data-mode="word">SELECT</button>
                </div>
            </div>
            <button class="absolute top-2 right-2 sm:top-4 sm:right-4 text-gray-400 hover:text-white text-xl sm:text-2xl" id="close-mode-popup">&times;</button>
        </div>

        <div id="settings-panel" class="hidden popup-panel w-full max-w-xs sm:max-w-lg">
            <h2 class="text-2xl sm:text-3xl font-bold mb-4 sm:mb-6 text-center text-blue-300 game-title">SETTINGS</h2>
            <p class="text-gray-300 mb-3 sm:mb-4 text-xs font-press-start text-center">Volume control, Difficulty (Start Level), etc.</p>
            <button id="close-settings-btn" class="w-full py-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-lg font-bold transition duration-200 font-press-start">CLOSE</button>
            <button class="absolute top-2 right-2 sm:top-4 sm:right-4 text-gray-400 hover:text-white text-xl sm:text-2xl" id="close-settings-popup">&times;</button>
        </div>

        <div id="history-panel" class="hidden popup-panel w-full max-w-xs sm:max-w-lg">
            <h2 class="text-2xl sm:text-3xl font-bold mb-4 sm:mb-6 text-center text-blue-300 game-title">HISTORY</h2>

            <div class="w-full max-w-full overflow-x-auto mb-4 sm:mb-6">
                <table id="history-table" class="min-w-full text-gray-300 font-press-start border-collapse">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Mode</th>
                            <th>Score</th>
                            <th>WPM</th>
                            <th>Accuracy</th>
                            <th>KPH</th>
                            <th>Duration</th>
                            <th>Date</th>
                        </tr>
                    </thead>
                    <tbody id="history-list">
                        <tr><td colspan="8" class="text-center">No history recorded yet.</td></tr>
                    </tbody>
                </table>
            </div>

            <button id="close-history-btn" class="mt-4 sm:mt-6 w-full py-3 bg-blue-600 hover:bg-blue-700 rounded-lg text-lg font-bold transition duration-200 font-press-start">CLOSE</button>
            <button class="absolute top-2 right-2 sm:top-4 sm:right-4 text-gray-400 hover:text-white text-xl sm:text-2xl" id="close-history-popup">&times;</button>
        </div>

        <div id="game-play" class="hidden relative w-full h-full bg-gray-900/90 p-2 sm:p-4">

            <div class="relative z-50 bg-gray-900/90 flex justify-between items-center mb-2 sm:mb-4 text-xs sm:text-xl font-bold font-press-start">
                <div id="lives-display" class="flex items-center space-x-1 sm:space-x-2 text-red-500">
                    <span class="text-lg sm:text-2xl">❤️</span><span id="life-count">5</span>
                </div>
                <div id="level-timer-display" class="text-yellow-400">
                    Time: <span id="time-left">00:30</span>
                </div>
                <div id="level-display" class="text-green-400">
                    Level: <span id="current-level">1</span>
                </div>
                <button id="back-to-menu-btn" class="text-xs py-1 px-2 sm:px-3 bg-red-600 hover:bg-red-700 rounded-lg transition duration-200 font-press-start">Menu</button>
            </div>

            <div id="bubble-fall-area" class="relative w-full h-[calc(100%-40px)] sm:h-[calc(100%-60px)] border-t-2 border-gray-700">
            </div>

            <div id="turret-assembly" class="flex items-end">
                <div id="mini-turret-left" class="mini-turret mr-3 sm:mr-6">
                    <div class="mini-gun-nozzle"></div>
                    <div class="mini-turret-display">+</div>
                </div>

                <div id="turret-base">
                    <div id="turret-explosion-container"></div>
                    <div id="turret-gun-nozzle"></div>
                    <div id="turret-display" class="font-press-start">
                        -
                    </div>
                </div>

                <div id="mini-turret-right" class="mini-turret ml-3 sm:ml-6">
                    <div class="mini-gun-nozzle"></div>
                    <div class="mini-turret-display">+</div>
                </div>
            </div>
            <div id="projectile" class="hidden"></div>
            <div id="projectile-left" class="mini-projectile hidden"></div>
            <div id="projectile-right" class="mini-projectile hidden"></div>
            <div class="absolute bottom-0 left-0 w-full h-1 bg-red-600 shadow-xl"></div>

            <input type="text" id="typing-input" maxlength="1" autofocus autocomplete="off" spellcheck="false">

        </div>

    </div>
    <div id="game-over-screen" class="hidden popup-panel w-full max-w-xs sm:max-w-lg">
        <h2 class="text-3xl sm:text-4xl font-bold mb-4 sm:mb-6 text-center text-red-500 game-title">GAME OVER</h2>

        <div class="w-full space-y-2 text-sm sm:text-base font-press-start">
            <p class="flex justify-between text-yellow-400">FINAL SCORE: <span id="final-score" class="font-bold">0</span></p>
            <p class="flex justify-between text-blue-300">WPM: <span id="final-wpm">0</span></p>
            <p class="flex justify-between text-blue-300">ACCURACY: <span id="final-accuracy">0%</span></p>
            <p class="flex justify-between text-blue-300">KPH: <span id="final-kph">0</span></p>
            <p class="flex justify-between text-blue-300">DURATION: <span id="final-duration">0m 0s</span></p>
        </div>

        <div class="mt-6 sm:mt-8 space-y-3 w-full">
            <button id="restart-game-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn"><span>RESTART</span></button>
            <button id="go-to-main-menu-btn" class="w-full py-3 rounded-lg text-lg sm:text-xl font-bold menu-btn menu-btn-secondary"><span>MAIN MENU</span></button>
        </div>
    </div>
    <script>
        const WORD_FALL_WORDS = [
            // Encoder/Data Processing Words (90 entries)
            "BYTE", "CODE", "BITS", "HASH", "MASK", "DATA", "FLOW", "KEY",
            "SEEK", "SYNC", "LOAD", "PASS", "SALT", "PAIR", "ALGO", "CIPHER",
            "BLOCK", "CHUNK", "FRAME", "QUEUE", "SHAPE", "VALUE", "DECODE",
            "ENCODE", "MATRIX", "STREAM", "SERIAL", "BUFFER", "PACKET", "HEADER",
            "OFFSET", "WINDOW", "LENGTH", "VECTOR", "COMPACT", "COMPRESS", "DECRYPT",
            "ENCRYPT", "PROCESS", "TRANSMIT", "PROTOCOL", "CONVERT", "PADDING",
            "REDUCE", "RESUME", "EXTRACT", "INJECT", "MAPPER", "PIPELINE", "SCHEMA",
            "SEGMENT", "TOKEN", "DIGEST", "SUBSTR", "BITWISE", "CHANNEL", "MESSAGE",
            "BOUNDARY", "SEQUENCE", "VALIDATE", "CHECKSUM", "DELIMITER", "DISTORT",
            "FUNCTION", "INTEGER", "ITERATE", "METADATA", "MIMETYPE", "NULLIFY",
            "PARSING", "PREDICT", "QUANTIZE", "REGISTER", "RESERVED", "REVERSE",
            "SUBSYSTEM", "TRANSFORM", "UNPACK", "VERSION", "BITRATE", "CONCAT",
            "CRYPTIC", "DEFLATE", "HUFFMAN", "LOSSLESS", "SIGNING",

            // Numeric Strings (80 entries - 3 to 7 characters)
            "101", "007", "4200", "55512", "9999999", "1234567", "00000",
            "7890", "314159", "2718", "600613", "8675309", "1337", "01101",
            "987654", "333", "77777", "404", "8888", "1024", "65535", "300",
            "1701", "255", "50000", "001", "2024", "1999", "54321", "111111",
            "8080", "443", "21", "22", "23", "80", "3389", "53",
            "192168", "127001", "1000", "999", "1111", "2048",
            "4096", "16", "32", "64", "128", "256", "512", "768",
            "365", "10995", "65536", "4095", "1000000", "987",
            "6789", "2468", "13579", "141421", "17320", "2236",
            "500", "10000", "777", "99", "456", "0800", "1500",
            "1600", "1800", "2000", "2500", "3000", "5000", "9000",
            "0000000", "10"
        ];

        const GAME_CONFIG = {
            currentMode: null,
            maxLives: 15,
            currentLives: 15,
            score: 0,

            // --- NEW METRICS TRACKING ---
            startTime: null,
            totalDuration: 0,
            correctKeystrokes: 0,
            incorrectKeystrokes: 0,
            // --- END NEW METRICS TRACKING ---

            currentLevel: 1,
            levelDuration: 30, // 30 seconds per level
            timeLeft: 30,
            levelTimerInterval: null,

            bubbleSpeedBase: 0.8,
            bubbleSpeedIncrease: 0.1,

            // BASE SPAWN RATES
            bubbleSpawnRateBase: 1200, // This will be used primarily for letters
            bubbleSpawnRateDecrease: 50,
            maxBubbles: 7,

            gameLoopInterval: null,
            // DEDICATED SPAWN INTERVALS ADDED
            spawnLoopInterval: null, // For letters/word fall
            symbolSpawnInterval: null,
            numberSpawnInterval: null,

            // NEW MINI TURRET INTERVALS
            miniTurretLeftInterval: null,
            miniTurretRightInterval: null,

            heartSpawned: false, // NEW FLAG to track heart drop for the current level

            // NEW: Word Fall Target Tracking
            activeWordTarget: null,
        };

        const BUBBLE_CHARACTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        const NUMBER_CHARACTERS = "0123456789";
        const SYMBOL_CHARACTERS = "!@#$%^&*()";
        const HISTORY_KEY = 'typingMadnessHistory';

        const BUBBLE_LIFE_CHANCE = 0.05; // 5% chance to spawn a multi-life bubble
        const MIN_BUBBLE_LIFE = 3;
        const MAX_BUBBLE_LIFE = 7;
        let CONTINUOUS_EXPLOSION_INTERVAL = null; // Global variable for continuous explosion loop

        let IDLE_ROTATION_INTERVAL = null;
        let MINI_TURRET_IDLE_INTERVAL = null; // New interval for mini turret idle rotation

        // --- Utility Functions (Including multi-life utilities) ---

        /**
         * Converts hex to RGBA with a specified alpha.
         */
        const hexToRgba = (hex, alpha) => {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        };

        /**
         * Calculates the color based on the bubble's remaining life (darker = more life).
         */
        const getBubbleColor = (life, maxLife) => {
            const BASE_BG_HEX = '#3b82f6'; // Blue-500
            const BASE_BORDER_HEX = '#93c5fd'; // Blue-300

            // Interpolation factor (0 at maxLife, 1 at 1 life)
            const factor = maxLife > 1 ? (maxLife - life) / (maxLife - 1) : 1;

            const interpolate = (startHex, endHex, f) => {
                const rStart = parseInt(startHex.slice(1, 3), 16);
                const gStart = parseInt(startHex.slice(3, 5), 16);
                const bStart = parseInt(startHex.slice(5, 7), 16);

                const rEnd = parseInt(endHex.slice(1, 3), 16);
                const gEnd = parseInt(endHex.slice(3, 5), 16);
                const bEnd = parseInt(endHex.slice(5, 7), 16);

                const r = Math.round(rStart + (rEnd - rStart) * f);
                const g = Math.round(gStart + (gEnd - gStart) * f);
                const b = Math.round(bStart + (bEnd - bStart) * f);

                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase()}`;
            };

            const START_BG_HEX = '#1e3a8a'; // Dark Blue-800
            const START_BORDER_HEX = '#3b82f6'; // Blue-500

            const interpolatedBg = interpolate(START_BG_HEX, BASE_BG_HEX, factor);
            const interpolatedBorder = interpolate(START_BORDER_HEX, BASE_BORDER_HEX, factor);

            return {
                bg: hexToRgba(interpolatedBg, 0.8),
                border: hexToRgba(interpolatedBorder, 0.9)
            };
        };


        /**
         * Updates the bubble's visual style and text based on its remaining life.
         */
        const updateBubbleAppearance = ($bubble, life, maxLife, content) => {
            if (life <= 1) {
                // Return to normal appearance (letter/char only)
                $bubble.text(content).css({
                    'background-color': '', // Clears inline style, relies on CSS .bubble
                    'border-color': '',
                    'border-style': ''
                }).removeClass('bubble-life'); // Remove class used for multi-life styling
            } else {
                // Apply life color and display life count
                const colors = getBubbleColor(life, maxLife);
                $bubble.text(life).css({
                    'background-color': colors.bg,
                    'border-color': colors.border,
                    'border-style': 'solid'
                }).addClass('bubble-life');
            }
        };

        /**
         * Visually updates a word bubble to show typed vs. remaining characters.
         */
        const updateWordBubbleDisplay = ($bubble) => {
            const fullWord = String($bubble.data('full-word') || '');
            const remainingWord = String($bubble.data('remaining-word') || '');
            const typedCount = $bubble.data('typed-count');

            if (!fullWord) return;

            const typedPart = fullWord.substring(0, typedCount);
            // The remaining part is simply the rest of the full word starting from the typedCount index
            const remainingPart = fullWord.substring(typedCount);

            // Highlight the typed part in blue/faint color, keep the remaining part white.
            const displayHtml = `<span class="text-blue-300 opacity-75">${typedPart}</span><span class="text-white">${remainingPart}</span>`;
            $bubble.html(displayHtml);
        };

        /**
         * Calculates typing metrics.
         * WPM: Correct keystrokes / 5 (avg word length) / total minutes
         * Accuracy: Correct keystrokes / total keystrokes
         * KPH: Total keystrokes / total hours
         */
        const calculateMetrics = (correctKeys, incorrectKeys, durationSeconds) => {
            const totalKeys = correctKeys + incorrectKeys;
            const durationMinutes = durationSeconds / 60;
            const durationHours = durationSeconds / 3600;
            const avgWordLength = 5; // Standard WPM calculation

            const wpm = durationMinutes > 0 ? Math.round((correctKeys / avgWordLength) / durationMinutes) : 0;
            const accuracy = totalKeys > 0 ? Math.round((correctKeys / totalKeys) * 100) : 0;
            const kph = durationHours > 0 ? Math.round(totalKeys / durationHours) : 0;

            const formatDuration = (s) => {
                const minutes = String(Math.floor(s / 60)).padStart(2, '0');
                const seconds = String(Math.round(s % 60)).padStart(2, '0');
                return `${minutes}m ${seconds}s`;
            };

            return {
                wpm: wpm,
                accuracy: accuracy,
                kph: kph,
                formattedDuration: formatDuration(durationSeconds),
                rawDuration: durationSeconds // Store raw duration for saving
            };
        };

        /**
         * UPDATED: Saves history with new typing metrics.
         */
        const saveHistory = (score, mode, correctKeys, incorrectKeys, durationSeconds) => {
            const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            const timestamp = new Date().toLocaleString();
            const metrics = calculateMetrics(correctKeys, incorrectKeys, durationSeconds);

            history.push({
                score,
                mode,
                timestamp,
                wpm: metrics.wpm,
                accuracy: metrics.accuracy,
                kph: metrics.kph,
                duration: metrics.formattedDuration,
            });
            localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        };

        /**
         * UPDATED: Loads history into the new table format.
         */
        const loadHistory = () => {
            const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
            const $list = $('#history-list');
            $list.empty();
            if (history.length === 0) {
                $list.append('<tr><td colspan="8" class="text-center">No history recorded yet.</td></tr>');
                return;
            }
            history.reverse().slice(0, 10).forEach((item, index) => {
                const row = `
                            <tr>
                                <td>${index + 1}.</td>
                                <td class="text-blue-300">${item.mode.toUpperCase()}</td>
                                <td class="text-yellow-400 font-bold">${item.score}</td>
                                <td>${item.wpm}</td>
                                <td>${item.accuracy}%</td>
                                <td>${item.kph}</td>
                                <td>${item.duration}</td>
                                <td>${item.timestamp}</td>
                            </tr>
                        `;
                $list.append(row);
            });
        };

        const toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        };

        const updateHUD = () => {
            $('#life-count').text(GAME_CONFIG.currentLives);
            $('#current-level').text(GAME_CONFIG.currentLevel);

            const minutes = String(Math.floor(GAME_CONFIG.timeLeft / 60)).padStart(2, '0');
            const seconds = String(GAME_CONFIG.timeLeft % 60).padStart(2, '0');
            $('#time-left').text(`${minutes}:${seconds}`);
        };

        /**
         * UPDATED: Sets the body flash to be softer and longer (0.7s) to be less jarring.
         */
        const flashIncorrect = () => {
            $('body').addClass('incorrect-flash-bg');
            setTimeout(() => {
                $('body').removeClass('incorrect-flash-bg');
            }, 700); // 700ms matches the new CSS animation duration

            // TRACK INCORRECT KEYSTROKES
            GAME_CONFIG.incorrectKeystrokes++;
        };

        /**
         * Creates an expanding, glowing explosion circle on the turret.
         */
        const turretExplosion = () => {
            const $container = $('#turret-explosion-container');
            // Create a new circle div with the explosion-circle animation class
            const $circle = $('<div class="explosion-circle"></div>');

            $container.append($circle);

            // The animation lasts 0.5s (500ms). Remove the div after it finishes.
            setTimeout(() => {
                $circle.remove();
            }, 550); // 50ms buffer
        };

        /**
         * Starts the continuous loop of the explosion effect.
         */
        const startContinuousExplosion = () => {
            if (CONTINUOUS_EXPLOSION_INTERVAL) return;
            // Loop the explosion effect slightly faster than the animation time
            CONTINUOUS_EXPLOSION_INTERVAL = setInterval(turretExplosion, 300);
        };

        /**
         * Stops the continuous explosion loop.
         */
        const stopContinuousExplosion = () => {
            if (CONTINUOUS_EXPLOSION_INTERVAL) {
                clearInterval(CONTINUOUS_EXPLOSION_INTERVAL);
                CONTINUOUS_EXPLOSION_INTERVAL = null;
            }
            // Also clean up any existing circles
            $('#turret-explosion-container').empty();
        };

        /**
         * Handles the turret firing animation for intermediate Word Fall hits.
         * This is identical to fireAndPop but skips the score/pop logic.
         */
        const fireOnly = ($targetBubble) => {
            const travelTime = 150;
            const $projectile = $('#projectile');
            const $turretBase = $('#turret-base');
            const $nozzle = $('#turret-gun-nozzle');
            const $gamePlay = $('#game-play');

            // 1. Calculate Target Coordinates and Angle
            const gamePlayRect = $gamePlay[0].getBoundingClientRect();
            const bubbleRect = $targetBubble[0].getBoundingClientRect();
            const targetX = bubbleRect.left + bubbleRect.width / 2 - gamePlayRect.left;
            const targetY = bubbleRect.top + bubbleRect.height / 2 - gamePlayRect.top;
            const turretRect = $turretBase[0].getBoundingClientRect();
            const turretCenterY = turretRect.top - gamePlayRect.top + $nozzle.height();
            const nozzleTipY = turretCenterY - $nozzle.height();
            const startX = turretCenterX = turretRect.left + turretRect.width / 2 - gamePlayRect.left;
            const startY = nozzleTipY;
            const deltaX = targetX - turretCenterX;
            const deltaY = targetY - nozzleTipY;
            const angleRad = Math.atan2(deltaY, deltaX);
            const angleDeg = angleRad * (180 / Math.PI) + 90;

            // Apply rotation to the nozzle
            $nozzle.css('transform', `rotate(${angleDeg}deg)`);

            // 2. Set projectile to start position and unhide
            $projectile.css({
                left: startX + 'px',
                top: startY + 'px',
                opacity: 1,
                transform: 'scale(1)',
                transition: 'none'
            }).removeClass('hidden');

            // 3. Trigger reflow before transition
            $projectile.get(0).offsetHeight;

            // 4. Trigger the movement animation
            $projectile.css({
                transition: `all ${travelTime}ms linear`,
                left: targetX + 'px',
                top: targetY + 'px',
                transform: 'scale(0.3)',
            });

            // 5. Reset projectile/turret after travel time (NO POP OR SCORING)
            setTimeout(() => {
                // Only trigger a small visual scale change on the target to show the hit
                $targetBubble.css({
                    transform: 'scale(1.05)',
                    transition: 'transform 0.1s'
                });
                setTimeout(() => $targetBubble.css('transform', 'scale(1)'), 100);

                // Reset projectile
                $projectile.addClass('hidden').css('transition', 'none');
                // Return to idle rotation after firing
                idleTurretRotation();
            }, travelTime);
        };

        /**
         * Handles the turret firing animation and bubble popping, including rotation.
         */
        const fireAndPop = ($targetBubble) => {
            const travelTime = 150;
            const $projectile = $('#projectile');
            const $turretBase = $('#turret-base');
            const $nozzle = $('#turret-gun-nozzle');
            const $gamePlay = $('#game-play');

            // 1. Calculate Target Coordinates and Angle
            const gamePlayRect = $gamePlay[0].getBoundingClientRect();
            const bubbleRect = $targetBubble[0].getBoundingClientRect();

            // Target center (relative to #game-play)
            const targetX = bubbleRect.left + bubbleRect.width / 2 - gamePlayRect.left;
            const targetY = bubbleRect.top + bubbleRect.height / 2 - gamePlayRect.top;

            // Turret center (relative to #game-play)
            const turretRect = $turretBase[0].getBoundingClientRect();
            const turretCenterX = turretRect.left + turretRect.width / 2 - gamePlayRect.left;
            const turretCenterY = turretRect.top - gamePlayRect.top + $nozzle.height(); // Pivot point is bottom of nozzle/top of display

            // Start position (Tip of the nozzle)
            const nozzleTipY = turretCenterY - $nozzle.height();
            const startX = turretCenterX;
            const startY = nozzleTipY;


            // Angle calculation
            const deltaX = targetX - turretCenterX;
            const deltaY = targetY - nozzleTipY;
            const angleRad = Math.atan2(deltaY, deltaX);
            // Convert to degrees and adjust (90 degrees offset for vertical barrel)
            const angleDeg = angleRad * (180 / Math.PI) + 90;

            // Apply rotation to the nozzle
            $nozzle.css('transform', `rotate(${angleDeg}deg)`);

            // 2. Set projectile to start position and unhide
            $projectile.css({
                left: startX + 'px',
                top: startY + 'px',
                opacity: 1,
                transform: 'scale(1)',
                transition: 'none'
            }).removeClass('hidden');

            // 3. Trigger reflow before transition
            $projectile.get(0).offsetHeight;

            // 4. Trigger the movement animation
            $projectile.css({
                transition: `all ${travelTime}ms linear`,
                left: targetX + 'px',
                top: targetY + 'px',
                transform: 'scale(0.3)',
            });

            // 5. Pop/Damage bubble and reset projectile/turret after travel time
            setTimeout(() => {

                // Get life/word data (Word Fall bubbles always pop here)
                const currentLife = parseInt($targetBubble.data('life') || 1);
                const maxLife = parseInt($targetBubble.data('max-life') || 1);
                const content = $targetBubble.data('full-text');

                // Determine if it's a bubble (with life/damage) or a word (instant pop)
                const isWordBubble = $targetBubble.data('is-word') === true;

                if (!isWordBubble && currentLife > 1) {
                    // DAMAGE THE MULTI-LIFE BUBBLE
                    $targetBubble.data('life', currentLife - 1);
                    updateBubbleAppearance($targetBubble, currentLife - 1, maxLife, content);

                    // Re-apply scale for a small hit-effect
                    $targetBubble.css({
                        transform: 'scale(1.1)',
                        transition: 'transform 0.1s'
                    });
                    setTimeout(() => $targetBubble.css('transform', 'scale(1)'), 100);

                } else {
                    // POP THE BUBBLE (Single life bubble or completed word)
                    $targetBubble.css({
                        transform: 'scale(1.2)',
                        opacity: 0,
                        transition: 'transform 0.1s, opacity 0.1s'
                    });
                    // Remove the bubble after its small visual transition
                    setTimeout(() => $targetBubble.remove(), 100);
                }

                // Reset projectile
                $projectile.addClass('hidden').css('transition', 'none');

                // Return to idle rotation after firing
                idleTurretRotation();

                // Update score immediately
                GAME_CONFIG.score += 10;

                // TRACK CORRECT KEYSTROKES HERE (The success of the full interaction)
                GAME_CONFIG.correctKeystrokes++;
            }, travelTime);
        };

        /**
         * NEW: Handles the automatic random firing of a mini turret.
         * @param {string} turretId - 'left' or 'right'
         */
        const miniTurretFireAndPop = (turretId) => {
            // Find all non-heart bubbles
            const $bubbles = $('#bubble-fall-area .bubble').not('.bubble-heart');
            if ($bubbles.length === 0) return;

            // Select a random bubble
            const randomIndex = Math.floor(Math.random() * $bubbles.length);
            const $targetBubble = $bubbles.eq(randomIndex);

            if (!$targetBubble || $targetBubble.length === 0) return;

            const travelTime = 200; // Slightly slower travel for mini turrets
            const $projectile = $(`#projectile-${turretId}`);
            const $turretBase = $(`#mini-turret-${turretId}`);
            const $nozzle = $turretBase.find('.mini-gun-nozzle');
            const $gamePlay = $('#game-play');

            // 1. Calculate Target Coordinates and Angle
            const gamePlayRect = $gamePlay[0].getBoundingClientRect();
            const bubbleRect = $targetBubble[0].getBoundingClientRect();

            // Target center (relative to #game-play)
            const targetX = bubbleRect.left + bubbleRect.width / 2 - gamePlayRect.left;
            const targetY = bubbleRect.top + bubbleRect.height / 2 - gamePlayRect.top;

            // Turret center/Pivot (relative to #game-play)
            const turretRect = $turretBase[0].getBoundingClientRect();
            // Pivot point is bottom of nozzle
            const turretCenterY = turretRect.top - gamePlayRect.top + $nozzle.height();
            const turretCenterX = turretRect.left + turretRect.width / 2 - gamePlayRect.left;

            // Start position (Tip of the nozzle)
            const nozzleTipY = turretCenterY - $nozzle.height();
            const startX = turretCenterX;
            const startY = nozzleTipY;

            // Angle calculation
            const deltaX = targetX - turretCenterX;
            const deltaY = targetY - nozzleTipY;
            const angleRad = Math.atan2(deltaY, deltaX);
            const angleDeg = angleRad * (180 / Math.PI) + 90;

            // Apply rotation to the nozzle
            $nozzle.css('transform', `rotate(${angleDeg}deg)`);

            // 2. Set projectile to start position and unhide
            $projectile.css({
                left: startX + 'px',
                top: startY + 'px',
                opacity: 1,
                transform: 'scale(1)',
                transition: 'none'
            }).removeClass('hidden');

            // 3. Trigger reflow before transition
            $projectile.get(0).offsetHeight;

            // 4. Trigger the movement animation
            $projectile.css({
                transition: `all ${travelTime}ms linear`,
                left: targetX + 'px',
                top: targetY + 'px',
                transform: 'scale(0.3)',
            });

            // 5. Pop the bubble and reset projectile/turret after travel time
            setTimeout(() => {
                // Mini turrets instantly pop the bubble, ignoring multi-life and words
                $targetBubble.css({
                    transform: 'scale(1.2)',
                    opacity: 0,
                    transition: 'transform 0.1s, opacity 0.1s'
                });
                setTimeout(() => $targetBubble.remove(), 100);

                // If the popped bubble was the active word target, reset it
                if ($targetBubble.is(GAME_CONFIG.activeWordTarget)) {
                    GAME_CONFIG.activeWordTarget = null;
                    $('#turret-display').text('-');
                }

                // Reset projectile
                $projectile.addClass('hidden').css('transition', 'none');

                // Return nozzle to scouting rotation
                miniTurretIdleRotation();

                // Mini turrets also grant score on pop
                GAME_CONFIG.score += 10;
            }, travelTime);
        };


        /**
         * Rotates the main turret nozzle slightly when no key is being pressed.
         */
        const idleTurretRotation = () => {
            const $nozzle = $('#turret-gun-nozzle');
            // Random angle between -45deg (left) and +45deg (right) for idle
            const randomAngle = Math.floor(Math.random() * 90) - 45;
            $nozzle.css('transform', `rotate(${randomAngle}deg)`);
        };

        /**
         * Rotates the mini turret nozzles randomly when idle (scouting).
         */
        const miniTurretIdleRotation = () => {
            const $nozzleLeft = $('#mini-turret-left').find('.mini-gun-nozzle');
            const $nozzleRight = $('#mini-turret-right').find('.mini-gun-nozzle');

            // Random angle between -60deg (left) and +60deg (right) for scouting
            const randomAngleL = Math.floor(Math.random() * 120) - 60;
            const randomAngleR = Math.floor(Math.random() * 120) - 60;

            $nozzleLeft.css('transform', `rotate(${randomAngleL}deg)`);
            $nozzleRight.css('transform', `rotate(${randomAngleR}deg)`);
        };

        const startIdleRotation = () => {
            if (IDLE_ROTATION_INTERVAL) clearInterval(IDLE_ROTATION_INTERVAL);
            IDLE_ROTATION_INTERVAL = setInterval(idleTurretRotation, 2500); // Change direction every 2.5 seconds
            idleTurretRotation(); // Initial rotation

            // NEW: Mini Turret Idle Rotation
            if (MINI_TURRET_IDLE_INTERVAL) clearInterval(MINI_TURRET_IDLE_INTERVAL);
            MINI_TURRET_IDLE_INTERVAL = setInterval(miniTurretIdleRotation, 1500); // Faster scouting
            miniTurretIdleRotation(); // Initial rotation
        };

        const stopIdleRotation = () => {
            if (IDLE_ROTATION_INTERVAL) {
                clearInterval(IDLE_ROTATION_INTERVAL);
                IDLE_ROTATION_INTERVAL = null;
            }
            // Reset main nozzle to center
            $('#turret-gun-nozzle').css('transform', 'rotate(0deg)');

            // NEW: Stop Mini Turret Idle Rotation
            if (MINI_TURRET_IDLE_INTERVAL) {
                clearInterval(MINI_TURRET_IDLE_INTERVAL);
                MINI_TURRET_IDLE_INTERVAL = null;
            }
            // Reset mini nozzles to vertical (0deg)
            $('#mini-turret-left').find('.mini-gun-nozzle').css('transform', 'rotate(0deg)');
            $('#mini-turret-right').find('.mini-gun-nozzle').css('transform', 'rotate(0deg)');
        };

        // NEW FUNCTION: Adds 1 life and gives a visual feedback
        const addLife = () => {
            GAME_CONFIG.currentLives++;
            updateHUD();
            // Reuse pulse animation for visibility on life count
            $('#lives-display').addClass('animate-pulse-effect');
            setTimeout(() => $('#lives-display').removeClass('animate-pulse-effect'), 1000);
        };

        // NEW FUNCTION: Spawns the heart item
        const spawnHeart = () => {
            // Check if heart should spawn (Level > 1 and hasn't spawned yet)
            if (GAME_CONFIG.currentLevel <= 1 || GAME_CONFIG.heartSpawned) return;

            const $area = $('#bubble-fall-area');
            const areaWidth = $area.width();
            const heartSize = 60;

            const content = "❤️";

            // Choose a random position for the heart
            const startX = Math.random() * (areaWidth - heartSize);

            // Add the heart bubble with a unique data-type
            const $heart = $(`<div class="bubble bubble-heart" data-type="heart">${content}</div>`);
            $heart.css({ left: startX + 'px' });
            $area.append($heart);

            GAME_CONFIG.heartSpawned = true;
        };


        // --- Level & Game State Logic ---

        const startLevelTimer = () => {
            if (GAME_CONFIG.levelTimerInterval) {
                clearInterval(GAME_CONFIG.levelTimerInterval);
            }

            GAME_CONFIG.timeLeft = GAME_CONFIG.levelDuration;
            updateHUD();

            // NEW: Schedule heart spawn for level 2+ within the first 5 seconds
            if (GAME_CONFIG.currentLevel > 1) {
                // Spawn after 4 seconds (within the requested first 5s window)
                setTimeout(spawnHeart, 4000);
            }

            GAME_CONFIG.levelTimerInterval = setInterval(() => {
                GAME_CONFIG.timeLeft--;
                updateHUD();

                if (GAME_CONFIG.timeLeft <= 0) {
                    clearInterval(GAME_CONFIG.levelTimerInterval);
                    nextLevel();
                }
            }, 1000);
        };

        const nextLevel = () => {
            GAME_CONFIG.currentLevel++;

            $('#bubble-fall-area').empty();
            GAME_CONFIG.activeWordTarget = null; // Clear target on level up
            $('#turret-display').text('-');

            startLevelTimer();

            // Reset heart spawn flag for the new level
            GAME_CONFIG.heartSpawned = false;

            // Clear and restart all spawn loops for the new level
            clearInterval(GAME_CONFIG.spawnLoopInterval);
            clearInterval(GAME_CONFIG.symbolSpawnInterval);
            clearInterval(GAME_CONFIG.numberSpawnInterval);
            startSpawnLoop();
        };

        const startGame = (mode) => {
            GAME_CONFIG.currentMode = mode;
            GAME_CONFIG.currentLives = GAME_CONFIG.maxLives;
            GAME_CONFIG.currentLevel = 1;
            GAME_CONFIG.score = 0;
            GAME_CONFIG.heartSpawned = false; // Reset for new game
            GAME_CONFIG.activeWordTarget = null; // Reset word target for new game

            // --- NEW METRICS INITIALIZATION ---
            GAME_CONFIG.correctKeystrokes = 0;
            GAME_CONFIG.incorrectKeystrokes = 0;
            GAME_CONFIG.startTime = Date.now();
            GAME_CONFIG.totalDuration = 0;
            // --- END METRICS INITIALIZATION ---

            stopContinuousExplosion(); // Stop continuous explosion when starting game

            $('#main-menu').hide();
            $('.popup-panel').fadeOut(0);
            $('#game-play').show();
            $('#game-over-screen').removeClass('popup-panel').hide();

            $('#bubble-fall-area').empty();
            $('#turret-display').text('-');

            $('#typing-input').val('').focus();
            // Max length is irrelevant in word mode since we only check the first character, but we set it high just in case.
            $('#typing-input').prop('maxlength', 1);

            $('#lives-display').toggle(mode !== 'word' || mode === 'word').show(); // Show lives in all modes
            $('#level-timer-display').show();
            $('#back-to-menu-btn').show();

            updateHUD();
            startGameLoop();
            startSpawnLoop();
            startLevelTimer();
            startIdleRotation();

            // MODIFICATION: Hide mini turrets in Word Fall mode, show in Bubble Burst mode.
            const $miniTurrets = $('#mini-turret-left, #mini-turret-right');
            if (mode === 'word') {
                $miniTurrets.hide();
            } else {
                $miniTurrets.show(); // Restore to default display (flex in CSS)
            }
            // MODIFICATION: Only start mini turret intervals in Bubble Burst mode
            // Clear any existing intervals (endGame should handle this, but for safety)
            clearInterval(GAME_CONFIG.miniTurretLeftInterval);
            clearInterval(GAME_CONFIG.miniTurretRightInterval);

            if (mode === 'bubble') {
                GAME_CONFIG.miniTurretLeftInterval = setInterval(() => {
                    miniTurretFireAndPop('left');
                }, 10000); // 10 seconds

                GAME_CONFIG.miniTurretRightInterval = setInterval(() => {
                    miniTurretFireAndPop('right');
                }, 11000); // 11 seconds
            } else {
                // Ensure intervals are null when not in bubble mode
                GAME_CONFIG.miniTurretLeftInterval = null;
                GAME_CONFIG.miniTurretRightInterval = null;
            }
        };

        const endGame = () => {
            // Stop all loops
            clearInterval(GAME_CONFIG.gameLoopInterval);
            clearInterval(GAME_CONFIG.spawnLoopInterval);
            clearInterval(GAME_CONFIG.levelTimerInterval);
            clearInterval(GAME_CONFIG.symbolSpawnInterval);
            clearInterval(GAME_CONFIG.numberSpawnInterval);

            // Ensure mini-turret intervals are cleared regardless of mode
            clearInterval(GAME_CONFIG.miniTurretLeftInterval);
            clearInterval(GAME_CONFIG.miniTurretRightInterval);

            stopIdleRotation();

            // CALCULATE FINAL DURATION AND METRICS
            GAME_CONFIG.totalDuration = (Date.now() - GAME_CONFIG.startTime) / 1000; // Total seconds
            const metrics = calculateMetrics(
                GAME_CONFIG.correctKeystrokes,
                GAME_CONFIG.incorrectKeystrokes,
                GAME_CONFIG.totalDuration
            );

            // SAVE HISTORY WITH METRICS
            saveHistory(
                GAME_CONFIG.score,
                GAME_CONFIG.currentMode,
                GAME_CONFIG.correctKeystrokes,
                GAME_CONFIG.incorrectKeystrokes,
                GAME_CONFIG.totalDuration
            );

            // UPDATE GAME OVER SCREEN
            $('#final-score').text(GAME_CONFIG.score);
            $('#final-wpm').text(metrics.wpm);
            $('#final-accuracy').text(metrics.accuracy + '%');
            $('#final-kph').text(metrics.kph);
            $('#final-duration').text(metrics.formattedDuration);


            const $gameOverScreen = $('#game-over-screen');
            $gameOverScreen.addClass('popup-panel').fadeIn(500);

            $('#typing-input').blur();
            startContinuousExplosion(); // Start continuous explosion on game over
        };

        const loseLife = () => {
            GAME_CONFIG.currentLives--;

            // If in word mode, an incorrect key also clears the target.
            if (GAME_CONFIG.currentMode === 'word') {
                GAME_CONFIG.activeWordTarget = null;
                $('#turret-display').text('-');
                // Reset display of all word bubbles (clear any partial typing)
                $('#bubble-fall-area .bubble-word').each(function () {
                    const $word = $(this);
                    const fullWord = $word.data('full-word');
                    $word.data('remaining-word', fullWord);
                    $word.data('typed-count', 0);
                    $word.text(fullWord); // Reset visual to full word (no styling)
                });
            }

            turretExplosion(); // Trigger single explosion when losing life
            $('#lives-display').addClass('heartbeat-animation');
            setTimeout(() => $('#lives-display').removeClass('heartbeat-animation'), 1000);
            updateHUD();

            // Losing a life counts as an incorrect action if not already tracked by flashIncorrect
            // We assume loseLife is called on bubble drop, which is NOT a keystroke, so we do not
            // increment incorrectKeystrokes here to maintain proper WPM/Accuracy.

            if (GAME_CONFIG.currentLives <= 0) {
                endGame();
            }
        };

        /**
         * Returns a random word from the predefined list.
         */
        const selectRandomWord = () => {
            return WORD_FALL_WORDS[Math.floor(Math.random() * WORD_FALL_WORDS.length)];
        };

        /**
         * Includes multi-life bubble spawning.
         */
        const spawnBubble = (type) => {
            const $area = $('#bubble-fall-area');
            const areaWidth = $area.width();

            let content;
            let bubbleClass = 'bubble';
            let bubbleSize = 50;

            let isMultiLife = false;
            let initialLife = 1;
            let $bubble;

            if (type === 'word') {
                content = selectRandomWord();
                bubbleClass = 'bubble ' + 'bubble-word';
                bubbleSize = 100;

                // Create word bubble with full word and word tracking attributes
                $bubble = $(`<div class="${bubbleClass}"
                                data-full-word="${content}"
                                data-remaining-word="${content}"
                                data-typed-count="0"
                                data-is-word="true">
                                ${content}
                            </div>`);

            } else {
                // Character-based bubble logic (Bubble Burst Mode)
                bubbleSize = 45;

                // Calculate multi-life chance only for letter/number/symbol bubbles
                if (Math.random() < BUBBLE_LIFE_CHANCE) {
                    isMultiLife = true;
                    initialLife = Math.floor(Math.random() * (MAX_BUBBLE_LIFE - MIN_BUBBLE_LIFE + 1)) + MIN_BUBBLE_LIFE;
                }

                if (type === 'symbol') {
                    content = SYMBOL_CHARACTERS.charAt(Math.floor(Math.random() * SYMBOL_CHARACTERS.length));
                    bubbleClass += ' bubble-symbol';
                } else if (type === 'number') {
                    content = NUMBER_CHARACTERS.charAt(Math.floor(Math.random() * NUMBER_CHARACTERS.length));
                    bubbleClass += ' bubble-number';
                } else {
                    content = BUBBLE_CHARACTERS.charAt(Math.floor(Math.random() * BUBBLE_CHARACTERS.length));
                }

                // Determine initial text for the bubble
                const initialText = isMultiLife ? initialLife : content;

                // Set data attributes for multi-life tracking
                $bubble = $(`<div class="${bubbleClass}" data-full-text="${content}" data-life="${initialLife}" data-max-life="${initialLife}">${initialText}</div>`);

                // Apply initial appearance for multi-life bubbles
                if (isMultiLife) {
                    updateBubbleAppearance($bubble, initialLife, initialLife, content);
                }
            }


            const startX = Math.random() * (areaWidth - bubbleSize);
            $bubble.css({ left: startX + 'px' });
            $area.append($bubble);
        };

        const startSpawnLoop = () => {
            clearInterval(GAME_CONFIG.spawnLoopInterval);
            clearInterval(GAME_CONFIG.symbolSpawnInterval);
            clearInterval(GAME_CONFIG.numberSpawnInterval);

            if (GAME_CONFIG.currentMode === 'word') {
                const currentRate = Math.max(
                    800, // Slightly slower base rate for words
                    GAME_CONFIG.bubbleSpawnRateBase - (GAME_CONFIG.currentLevel * GAME_CONFIG.bubbleSpawnRateDecrease * 2)
                );

                GAME_CONFIG.spawnLoopInterval = setInterval(() => {
                    if ($('#bubble-fall-area > div').length < GAME_CONFIG.maxBubbles) {
                        spawnBubble('word');
                    }
                }, currentRate);

            } else if (GAME_CONFIG.currentMode === 'bubble') {

                const letterRate = Math.max(
                    300,
                    GAME_CONFIG.bubbleSpawnRateBase - (GAME_CONFIG.currentLevel * GAME_CONFIG.bubbleSpawnRateDecrease)
                );

                GAME_CONFIG.spawnLoopInterval = setInterval(() => {
                    if ($('#bubble-fall-area > div').length < GAME_CONFIG.maxBubbles) {
                        spawnBubble('letter');
                    }
                }, letterRate);

                GAME_CONFIG.numberSpawnInterval = setInterval(() => {
                    if ($('#bubble-fall-area > div').length < GAME_CONFIG.maxBubbles) {
                        spawnBubble('number');
                    }
                }, 5000);

                GAME_CONFIG.symbolSpawnInterval = setInterval(() => {
                    if ($('#bubble-fall-area > div').length < GAME_CONFIG.maxBubbles) {
                        spawnBubble('symbol');
                    }
                }, 15000);
            }
        };

        const startGameLoop = () => {
            let animationFrameId;
            // Constant for 5 seconds at an assumed 60 FPS
            const HEART_TARGET_FRAMES = 5 * 60;

            const fallBubbles = () => {
                const speed = GAME_CONFIG.bubbleSpeedBase + (GAME_CONFIG.currentLevel * GAME_CONFIG.bubbleSpeedIncrease);
                const $area = $('#bubble-fall-area');
                const areaHeight = $area.height();

                // Calculate the required speed for the heart bubble based on current area height
                const heartSpeed = areaHeight / HEART_TARGET_FRAMES;

                $('#bubble-fall-area > div').each(function () {
                    const $item = $(this);
                    let currentY = $item.position().top;

                    // Determine which speed to use
                    const itemSpeed = $item.hasClass('bubble-heart') ? heartSpeed : speed;

                    const newY = currentY + itemSpeed; // Use the determined speed

                    if (newY >= areaHeight - $item.outerHeight()) {

                        // NEW LOGIC: Check if the item is a heart
                        if ($item.hasClass('bubble-heart')) {
                            $item.remove();
                            addLife(); // Add life instead of losing one
                        } else {
                            // Original logic for normal bubbles/words
                            $item.remove();
                            loseLife(); // loseLife does not track incorrect keystrokes

                            // If the item removed was the active target, clear it
                            if ($item.is(GAME_CONFIG.activeWordTarget)) {
                                GAME_CONFIG.activeWordTarget = null;
                                $('#turret-display').text('-');
                            }
                        }
                    } else {
                        $item.css({ top: newY + 'px' });
                    }
                });

                if (GAME_CONFIG.gameLoopInterval) {
                    cancelAnimationFrame(GAME_CONFIG.gameLoopInterval);
                }

                animationFrameId = requestAnimationFrame(fallBubbles);
                GAME_CONFIG.gameLoopInterval = animationFrameId;
            };

            animationFrameId = requestAnimationFrame(fallBubbles);
            GAME_CONFIG.gameLoopInterval = animationFrameId;
        };

        // --- Event Handlers ---

        $(document).ready(function () {

            // Menu Buttons
            $('#start-game-btn').on('click', function () {
                $('#game-mode-popup').fadeIn(300);
                $('#typing-input').blur();
            });
            $('#settings-btn').on('click', function () { $('#settings-panel').fadeIn(300); });
            $('#fullscreen-btn').on('click', toggleFullscreen);
            $('#history-btn').on('click', function () { loadHistory(); $('#history-panel').fadeIn(300); });

            // Close Popup buttons
            $('.popup-panel .absolute.top-2.right-2, .popup-panel .absolute.top-4.right-4, .popup-panel button:contains("CLOSE")').on('click', function () {
                $(this).closest('.popup-panel').fadeOut(300);
                $('#typing-input').focus();
            });
            $('#close-mode-popup').on('click', function () {
                $('#game-mode-popup').fadeOut(300);
                $('#typing-input').focus();
            });


            // Game Mode Selection
            $('.select-mode-btn').on('click', function () {
                const mode = $(this).data('mode');
                startGame(mode);
            });

            // In-Game Menu Button (quitting mid-game)
            $('#back-to-menu-btn').on('click', function () {
                // Since this is a mid-game quit, we DO NOT record stats.
                clearInterval(GAME_CONFIG.gameLoopInterval);
                clearInterval(GAME_CONFIG.spawnLoopInterval);
                clearInterval(GAME_CONFIG.levelTimerInterval);
                clearInterval(GAME_CONFIG.symbolSpawnInterval);
                clearInterval(GAME_CONFIG.numberSpawnInterval);
                clearInterval(GAME_CONFIG.miniTurretLeftInterval); // Clear mini turret intervals
                clearInterval(GAME_CONFIG.miniTurretRightInterval); // Clear mini turret intervals
                stopIdleRotation();
                stopContinuousExplosion(); // Stop explosion if running
                $('#bubble-fall-area').empty();
                $('#game-play').hide();
                $('#main-menu').fadeIn(300);
            });

            // Game Over Restart Button Handler
            $('#restart-game-btn').on('click', function () {
                $('#game-over-screen').removeClass('popup-panel').hide();
                startGame(GAME_CONFIG.currentMode);
            });

            // Game Over Menu Button Handler
            $('#go-to-main-menu-btn').on('click', function () {
                $('#game-over-screen').removeClass('popup-panel').hide();
                stopContinuousExplosion(); // Stop explosion
                $('#bubble-fall-area').empty();
                $('#game-play').hide();
                $('#main-menu').fadeIn(300);
            });


            // Typing Input Logic
            $('#typing-input').on('input', function (event) {
                if ($('#game-over-screen').is(':visible')) {
                    $(this).val('');
                    return;
                }

                const rawTypedText = $(this).val();
                $(this).val('');

                if (!rawTypedText) return;

                let typedChar = rawTypedText.charAt(0).toUpperCase(); // Always check uppercase

                // TRACK KEYSTROKE ATTEMPTS (Before match check, as all keypresses are attempts)
                // This is tracked regardless of success/failure, as flashIncorrect also tracks a failure.

                // 2. Update the visual display (shows what was typed for a moment)
                // We keep this line commented as in the original to show next expected character/default dash.
                // $('#turret-display').text(typedChar);

                // 3. Game logic check
                if (GAME_CONFIG.currentMode === 'bubble') {
                    // --- BUBBLE BURST LOGIC ---

                    let $targetBubble = null;
                    let lowestY = -Infinity;

                    // Find the lowest bubble matching the typed character
                    $('#bubble-fall-area .bubble').each(function () {
                        const $this = $(this);

                        // FIX: Check if the currently displayed text of the bubble matches the typed character, but ignore hearts.
                        if (!$this.hasClass('bubble-heart') && !$this.data('is-word') && $this.text().toString() === typedChar) {
                            const currentY = $this.position().top;
                            if (currentY > lowestY) {
                                lowestY = currentY;
                                $targetBubble = $this;
                            }
                        }
                    });

                    if ($targetBubble) {
                        // Success! Fire the turret and pop/damage the bubble.
                        fireAndPop($targetBubble);
                        $('#turret-display').text('-'); // Clear display after successful shot
                    } else {
                        // INCORRECT KEYPRESS - LOSE A LIFE
                        flashIncorrect(); // Tracks incorrect keystrokes
                        loseLife();
                        // Turret resets to idle after an incorrect shot
                        idleTurretRotation();
                    }
                }
                else if (GAME_CONFIG.currentMode === 'word') {
                    // --- WORD FALL LOGIC ---
                    let $target = GAME_CONFIG.activeWordTarget;
                    let isMatch = false;
                    if (!$target) {

                        // 1. Find a new target (lowest word bubble whose first letter/character matches)
                        let lowestY = -Infinity;

                        $('#bubble-fall-area .bubble-word').each(function () {
                            const $this = $(this);
                            const remaining = String($this.data('remaining-word') || '');

                            // The typedChar is uppercase, but this works fine for numbers too
                            if (remaining && remaining.charAt(0).toUpperCase() === typedChar) {
                                const currentY = $this.position().top;
                                if (currentY > lowestY) {
                                    lowestY = currentY;
                                    $target = $this;
                                }
                            } 
                        });

                        if ($target) {
                            GAME_CONFIG.activeWordTarget = $target;
                            isMatch = true;
                        }
                    }

                    if ($target) {
                        // 2. Process the character on the active target
                        const remaining = String($target.data('remaining-word') || '');

                        // The typedChar is uppercase, and we compare it to the uppercase version of the target's next character
                        if (remaining && remaining.charAt(0).toUpperCase() === typedChar) {
                            isMatch = true;

                            // Consume the character
                            const newRemaining = remaining.substring(1);
                            const newTypedCount = $target.data('typed-count') + 1;

                            $target.data('remaining-word', newRemaining);
                            $target.data('typed-count', newTypedCount);

                            updateWordBubbleDisplay($target);

                            // TRACK CORRECT KEYSTROKES FOR WORD TYPING (EACH LETTER IS A CORRECT STROKE)
                            GAME_CONFIG.correctKeystrokes++;

                            // Set turret display to the NEXT expected character
                            // We display the original case from the word list, but the check still uses uppercase.
                            $('#turret-display').text(newRemaining.charAt(0) || '✓');

                            if (newRemaining.length === 0) {
                                // Word complete!
                                fireAndPop($target); // Will fire and score, but correctKeystrokes is already updated for the last character
                                GAME_CONFIG.activeWordTarget = null;
                                $('#turret-display').text('-');
                            } else {
                                fireOnly($target);
                            }
                        }
                    }

                    if (!isMatch) {
                        // Incorrect keypress or no match found
                        flashIncorrect(); // Tracks incorrect keystrokes
                        loseLife();
                        // Turret resets to idle after an incorrect shot
                        idleTurretRotation();
                    } else if (isMatch) {
                        // On successful match, reset input display to show next expected letter
                        if ($target && $target.data('remaining-word').length > 0) {
                            $('#turret-display').text($target.data('remaining-word').charAt(0));
                        }
                    }
                }
            });

            // Focus the input when game-play is visible
            $(document).on('click', '#game-play', function () {
                if (!$('#game-over-screen').is(':visible')) {
                    $('#typing-input').focus();
                }
            });

            $('#start-game-btn').focus();
        });
    </script>
</body>

</html>
