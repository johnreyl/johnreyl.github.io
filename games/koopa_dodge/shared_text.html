<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Koopa Fireball Dodge (MP3 Fallback & Flip & Quad Controls)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* 1. Global & Font Setup (Full Viewport Size) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden; 
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #2d3748; 
            display: flex; 
            flex-direction: column;
        }

        /* 2. Responsive Font Adjustments & Scoreboard Styling */
        #scoreboard {
            width: 100%;
            height: 40px; 
            margin: 0;
            display: flex;
            justify-content: space-between;
            align-items: center; 
            background-color: #2d3748; 
            color: white;
            padding: 0 12px;
            border-radius: 0; 
            font-weight: bold;
            flex-shrink: 0;
            font-size: 1rem;
        }
        @media (max-width: 640px) {
            #scoreboard {
                font-size: 0.875rem; 
            }
            #game-over-message {
                font-size: 2rem !important;
            }
        }
        #current-score { color: #f9d71c; margin: 0 10px; }
        #top-score { color: #ed8936; }
        #triple-jump-cooldown { 
            font-size: 0.9rem;
            min-width: 110px;
            text-align: right;
            padding-right: 5px;
        }

        /* Heart SVG Styling */
        #lives-display { display: flex; align-items: center; gap: 2px; }
        .heart-icon { width: 16px; height: 16px; fill: #E53E3E; stroke: #A03232; }
        .empty-heart { fill: none; stroke: #A03232; }

        /* Fullscreen Button Styling */
        #fullscreen-btn {
            cursor: pointer;
            margin-left: 10px;
            opacity: 0.8;
            transition: opacity 0.1s;
        }
        #fullscreen-btn:hover { opacity: 1; }

        /* 3. Game Container Styling */
        #game-container {
            width: 100%; 
            height: calc(100vh - 40px); 
            max-width: none;
            position: relative;
            overflow: hidden;
            margin: 0;
            background-color: #79a1d1; 
            border: none; 
            border-radius: 0;
            box-shadow: none; 
            cursor: pointer; 
            transition: transform 0.5s ease; 
            flex-grow: 1;
        }

        /* Wiggle Animation for Game Over AND Speed Reset */
        @keyframes wiggle {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            25% { transform: translateX(-4px) rotate(-0.5deg); }
            75% { transform: translateX(4px) rotate(0.5deg); }
        }
        .wiggle { animation: wiggle 0.1s ease-in-out 5; }
        .wiggle-short { animation: wiggle 0.3s ease-in-out 1; }
        
        /* Ground with Parallax Adjustment */
        #game-ground {
            position: absolute;
            bottom: 0;
            left: 0; 
            height: 35px;
            background-color: #38703a; 
            z-index: 5;
            transition: left 0.1s linear; 
            background-image: repeating-linear-gradient(
                45deg,
                #38703a,
                #38703a 10px,
                #346836 10px,
                #346836 20px
            );
        }
        
        /* NEW: Pipe Styling - Width will be set by JS dynamically */
        #game-pipe {
            position: absolute;
            bottom: 35px; /* Sits on the ground */
            /* width: 90px; - Removed, set by JS */
            height: 50px;
            z-index: 9; 
            /* Pipe body */
            background-color: #1A5630;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            /* Pipe rim/top */
            box-shadow: 0 -8px 0 0 #32a852, /* Top Rim */
                        inset 0 4px 0 rgba(0,0,0,0.2); /* Inner Shadow */
        }
        
        /* Platform Base Styling (JS will create and position) */
        .game-platform {
            position: absolute;
            background-color: #f6ad55; 
            z-index: 9; 
            border-radius: 2px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }


        /* Character Base Styling (Koopa) */
        .character {
            position: absolute;
            bottom: 35px;
            z-index: 10;
            width: 55px;
            height: 55px;
            /* Added transition for smooth movement and flip */
            transition: transform 0.2s ease-out, left 0.1s linear; 
        }

        /* Koopa Flip State */
        .koopa-flip {
            transform: scaleX(-1);
        }

        #koopa {
            transition: left 0.1s linear; 
        }

        /* Visual cue for invincibility (after being hit) */
        .koopa-invincible {
            opacity: 0.6;
            animation: blink-koopa 0.1s infinite alternate;
        }
        @keyframes blink-koopa {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        /* Fireball Rotation Animation */
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Fireball Styling */
        .fireball {
            position: absolute;
            z-index: 8;
            transition: opacity 0.2s;
        }
        
        .fireball svg {
            width: 100%;
            height: 100%;
            animation: rotate 1s linear infinite; 
        }
        /* Overlay and Button styles */
        #game-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            color: white; text-align: center;
        }
        #play-button {
            background-color: #ed8936; padding: 12px 24px; border-radius: 8px;
            font-weight: bold; font-size: 1.25rem; cursor: pointer;
            box-shadow: 0 4px 0 #c06c1c; transition: all 0.1s ease-in-out;
        }
        #play-button:hover { background-color: #f6ad55; }
        #play-button:active { box-shadow: 0 1px 0 #c06c1c; transform: translateY(3px); }
        #game-over-message { font-size: 2.5rem; font-weight: 900; color: #ff0000; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8); margin-bottom: 20px; }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'brand-charcoal': '#2d3748',
                        'brand-orange': '#ed8936',
                        'text-gray': '#4a5568',
                    }
                }
            }
        }

        // =======================================================================
        // TONE.JS SOUND CONFIGURATION (Synth Fallback) 
        // =======================================================================
        const SOUND_CONFIG = {
            // Koopa: Lose life (sharper, high-pitch, descending arcade hit)
            koopaDamage: { type: 'synth', notes: ['F#5', 'D5'], duration: 0.1, wave: 'square', velocity: 0.8 }, 
            
            // Fireball: Normal ground bounce (Fast, metallic, low pitch)
            fireballBounceGround: { type: 'membrane', notes: ['C2', 'C#2'], duration: 0.08, velocity: 0.9, pitchDecay: 0.05 },
            
            // Fireball: Boost reset (Aggressive, low pitch, indicates speed loss/reset)
            fireballBoostReset: { type: 'membrane', notes: ['G1', 'D1'], duration: 0.3, velocity: 1.0, pitchDecay: 0.1 }, 
            
            // Fireball: Platform collision / Fireball-Fireball bounce / NEW: Pipe Bounce (Very high-pitch, sharp, for speed gain/boost)
            fireballPlatformBounce: { type: 'synth', notes: ['A6', 'C7'], duration: 0.05, wave: 'triangle', velocity: 0.7 }, 
            
            // UI: Click/Change (Simple, clean blip) - Used for buttons/dropdown change
            uiClick: { type: 'synth', notes: ['G5'], duration: 0.04, wave: 'sine' },
            
            // UI: Hover/Focus (Slightly lower pitch blip) - Used for hover/focus
            uiHover: { type: 'synth', notes: ['E5'], duration: 0.03, wave: 'sine' }, 
            
            // Game Over: Dramatic, minor chord for boss defeat
            gameOver: { type: 'synth', notes: ['A2', 'C3', 'E3'], duration: 1.5, wave: 'sawtooth', velocity: 0.6 }, 
            
            // Max Score: Aggressive ascending victory chime
            maxScore: { type: 'synth', notes: ['C6', 'E6', 'G6', 'C7'], duration: 0.4, wave: 'square', velocity: 0.9 },
            
            // Background Music (A Minor Arpeggio - Boss Battle Theme)
            backgroundMusic: { notes: ['A3', 'C4', 'E4', 'A4'], tempo: '6n', wave: 'square' },
            
            // Menu Music (C Major Arpeggio - Calm Theme)
            menuMusic: { notes: ['C4', 'E4', 'G4', 'C5'], tempo: '4n', wave: 'sine' }
        };
        // =======================================================================
        
        // =======================================================================
        // LOCAL MP3 SOUND CONFIGURATION (Priority Over Tone.js)
        // NOTE: These are placeholders and rely on the embedding environment providing them
        // The tone.js synth fallbacks will be used if these paths fail.
        // =======================================================================
        const LOCAL_SOUND_CONFIG = {
            koopaDamage: 'audio3/koopa_damage.mp3',
            fireballBounceGround: 'audio3/fireball_bounce.mp3',
            fireballBoostReset: 'audio3/boost_reset.mp3',
            fireballPlatformBounce: 'audio3/platform_bounce.mp3',
            uiClick: 'audio3/koopa_damage.mp3', 
            uiHover: 'audio3/koopa_damage.mp3',
            gameOver: 'audio3/game_over.mp3',
            maxScore: 'audio3/koopa_damage.mp3',
            backgroundMusic: 'audio/background_music.mp3' 
        };
        // =======================================================================
        

        $(document).ready(function() {
            // --- Tone.js Setup Variables ---
            let audioContextInitialized = false;
            let mainSynth = null;
            let membraneSynth = null;
            let squareSynth = null; 
            let backgroundLoop = null; // Game Music Fallback Loop
            let menuLoop = null; // Menu Music Fallback Loop
            let backgroundPlayer = null; // Game Music MP3 Player
            let soundPlayers = {}; 
            let mp3LoadingFailed = {}; 

            // --- Elements ---
            const $gameContainer = $('#game-container');
            const $koopa = $('#koopa');
            const $gameGround = $('#game-ground');
            const $gamePipe = $('#game-pipe'); // NEW: Pipe Element
            const $overlay = $('#game-overlay');
            const $playButton = $('#play-button');
            const $fireballSelect = $('#fireball-select'); 
            const $difficultySelect = $('#difficulty-select'); 
            const $gameOverMessage = $('#game-over-message');
            const $currentScoreDisplay = $('#current-score');
            const $topScoreDisplay = $('#top-score');
            const $fireballTemplate = $('#fireball-template');
            const $fullscreenBtn = $('#fullscreen-btn');
            const $tripleJumpDisplay = $('#triple-jump-cooldown'); 
            const $platformWarning = $('#platform-warning'); 
            const $soundToggle = $('#sound-toggle'); 
            const $devModeToggle = $('#dev-mode-toggle'); // NEW: Dev Mode Toggle

            // --- Constants ---
            const GROUND_HEIGHT = 35;
            const PLAYER_WIDTH = 55;
            const PLAYER_HEIGHT = 55;
            const FIREBALL_SIZE = 15;
            const JUMP_BASE_HEIGHT = 70; 
            const JUMP_DURATION_UP = 200; 
            const JUMP_DURATION_DOWN = 600; 
            const MOVE_STEP = 10; // BASE movement step
            const MOVE_STEP_BOOST = 20; // Double-tap movement boost step
            const DOUBLE_TAP_INTERVAL_MS = 300; // Max time between taps for boost
            const PARALLAX_STEP = 5; 
            const GROUND_EXTRA_WIDTH = 100; 
            const FIREBALL_BASE_SPEED = 5;
            const SPEED_INCREASE_FACTOR = 0.5;
            const COLLISION_BUFFER = 5; 
            const MIN_START_DISTANCE = 100;
            const STORAGE_KEY = 'koopaDodgeTopScore';
            const SOUND_STORAGE_KEY = 'koopaDodgeSoundEnabled'; 
            const DEV_MODE_STORAGE_KEY = 'koopaDodgeDevMode'; // NEW: Dev Mode Storage
            const MAX_JUMPS = 3; 
            const TRIPLE_JUMP_COOLDOWN_MS = 40000; 
            const MAX_JUMP_RATIO = 0.75; 
            const PLATFORM_WIDTH = 200; 
            const PLATFORM_HEIGHT = 5;
            const PLATFORM_SPEED = 3; 
            const PLATFORM_SPEED_MULTIPLIER = 3; 
            const FIREBALL_FIREBALL_BOOST_MULTIPLIER = 2.0; // NEW: Multiplier for F-F collision
            const PLATFORM_TOP_MARGIN = 50; 
            const PLATFORM_VERTICAL_SPACING = 50; 
            const WIGGLE_DURATION_MS = 300; 
            const MAX_LIVES = 5;
            const INITIAL_LIVES = 3;
            const HEAL_INTERVAL_MS = 60000; 
            const DAMAGE_COOLDOWN_MS = 1000; 
            const INITIAL_FIREBALL_DELAY = 3000; 
            const SPEED_INTERVAL_MS = 60000; 
            const DUPLICATION_INTERVAL_MS = 20000; 
            const DUPLICATION_DELAY_MS = 2000; 
            const MIN_FIREBALLS = 1;
            const MAX_FIREBALLS = 25;
            
            // NEW: Pipe Constants (Dynamic Width)
            const PIPE_WIDTH = PLAYER_WIDTH * 1.2; // Adjusted width
            const PIPE_HEIGHT = 50;
            const PIPE_RIM_HEIGHT = 8; // From CSS box-shadow

            // --- State Management ---
            let isPlaying = false;
            let isSoundEnabled = true; 
            let isDevMode = false; // NEW: Developer Mode State
            let jumpsCompleted = 0; 
            let lastTripleJumpTime = 0; 
            let lastDamageTime = 0;
            let gameLoopInterval = null;
            let scoreInterval = null;
            let speedUpInterval = null;
            let duplicationInterval = null;
            let healInterval = null;
            let currentScore = 0;
            let currentSpeed = FIREBALL_BASE_SPEED; 
            let koopaLives = INITIAL_LIVES;
            let currentDifficulty = 'medium'; 
            let topScoreAchievedDuringGame = false; 
            let koopaX = 0; 
            let groundOffsetX = 0; 
            let currentFlipState = 0; 
            let platforms = []; 
            let pipe = {}; // NEW: Pipe Object State
            let gameContainerWidth = 0;
            let gameContainerHeight = 0;
            let groundMaxMovement = 0; 
            let fireballs = []; 
            let tjCooldownTimer = null; 
            
            // -------------------------------------------------------------------
            // VARIABLES FOR CONTINUOUS MOVEMENT
            // -------------------------------------------------------------------
            
            // Tracks which movement keys are currently held down
            let keysHeld = {};
            
            // Tracks touch hold state for continuous mobile movement (NEW)
            let touchHeld = false; 
            let touchDirection = 0; // -1: Left, 1: Right, 0: None 

            // The effective speed for continuous movement, updated only on keydown for boost
            let currentLeftMoveStep = MOVE_STEP;
            let currentRightMoveStep = MOVE_STEP;

            // Existing variables, now ONLY used for double-tap detection in keydown/touchstart
            let lastMoveLeftTime = 0; 
            let lastMoveRightTime = 0; 
            
            // -------------------------------------------------------------------

            // --- Tone.js Audio Functions (Unchanged) ---
            
            function playToneSound(soundName) {
                if (!audioContextInitialized || !SOUND_CONFIG[soundName] || !isSoundEnabled) return; 
                
                const config = SOUND_CONFIG[soundName];
                const now = Tone.now();
                
                const notes = Array.isArray(config.notes) ? config.notes : [config.notes];

                if (config.type === 'synth' && (mainSynth || squareSynth)) {
                    let synthToUse = mainSynth;
                    
                    if (config.wave === 'square' && squareSynth) {
                        synthToUse = squareSynth;
                    } else if (config.wave && (config.wave !== 'square' || !squareSynth)) {
                         synthToUse = new Tone.PolySynth(Tone.Synth, {
                             oscillator: { type: config.wave },
                             envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 },
                             volume: config.volume || 0 
                         }).toDestination();
                    }
                    
                    synthToUse.triggerAttackRelease(notes, config.duration || '8n', now, config.velocity || 0.5);
                    
                    if (synthToUse !== mainSynth && synthToUse !== squareSynth) {
                         setTimeout(() => synthToUse.dispose(), (config.duration || 0.5) * 1000 + 100);
                    }
                } else if (config.type === 'membrane' && membraneSynth) {
                    notes.forEach((note, index) => {
                        membraneSynth.triggerAttackRelease(note, config.duration || '8n', now + (index * 0.01), config.velocity || 0.8);
                    });
                }
            }

            function playSound(soundName) {
                if (!audioContextInitialized || !isSoundEnabled) return; 

                if (mp3LoadingFailed[soundName]) {
                    playToneSound(soundName);
                    return;
                }

                const player = soundPlayers[soundName];
                
                if (player && player.loaded) {
                    player.stop(); // Stop previous playback if any
                    player.start();
                } else {
                    playToneSound(soundName);
                }
            }
            
            function playUiClick() {
                playSound('uiClick');
            }
            
            function playUiHover() {
                 playSound('uiHover');
            }

            // Consolidated function to stop all music loops/players
            function stopAllMusic() {
                if (!audioContextInitialized) return;
                Tone.Transport.stop(); 
                if (menuLoop && menuLoop.state === 'started') menuLoop.stop();
                if (backgroundLoop && backgroundLoop.state === 'started') backgroundLoop.stop();
                
                // Stop the MP3 player only if it's currently playing
                if (backgroundPlayer && backgroundPlayer.state === 'started') {
                    backgroundPlayer.stop();
                }
            }
            
            // Function to start the menu music
            function startMenuMusic() {
                if (!audioContextInitialized || !isSoundEnabled) return;
                stopAllMusic(); 

                Tone.Transport.start(); 
                if (menuLoop) menuLoop.start(0); 
            }

            // Function to start the game music 
            function startBackgroundMusic() {
                if (!audioContextInitialized || !isSoundEnabled) { 
                    return;
                }
                stopAllMusic(); 
                
                Tone.Transport.start(); 

                // MP3 has priority
                if (backgroundPlayer && backgroundPlayer.loaded && !mp3LoadingFailed.backgroundMusic) {
                    if (backgroundPlayer.state !== 'started') {
                        backgroundPlayer.start(0);
                    }
                } else if (backgroundLoop) {
                    backgroundLoop.start(0); 
                }
            }


            // Must be called on the first user interaction
            function initializeAudioContext() {
                if (audioContextInitialized) return;
                
                Tone.start().then(() => {
                    // Initialize Synths
                    mainSynth = new Tone.PolySynth(Tone.Synth, {
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 },
                        volume: -15 // Reduced volume for general synths
                    }).toDestination();
                    
                    membraneSynth = new Tone.MembraneSynth({
                        pitchDecay: 0.02,
                        octaves: 2,
                        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.1, attackCurve: "exponential" },
                        volume: -5
                    }).toDestination();

                    // Dedicated Synth for Chiptune BG Music (Volume lowered)
                    squareSynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "square" }, 
                        volume: -15
                    }).toDestination();

                    Tone.Transport.bpm.value = 140; 
                    
                    // 1. Setup Tone.js Music Loops

                    const gameMusicConfig = SOUND_CONFIG.backgroundMusic;
                    let noteIndex = 0;
                    backgroundLoop = new Tone.Loop(time => {
                        const note = gameMusicConfig.notes[noteIndex % gameMusicConfig.notes.length];
                        squareSynth.triggerAttackRelease(note, "8n", time, 0.5); 
                        noteIndex++;
                    }, gameMusicConfig.tempo); 

                    const menuMusicConfig = SOUND_CONFIG.menuMusic;
                    let menuNoteIndex = 0;
                    menuLoop = new Tone.Loop(time => {
                        const note = menuMusicConfig.notes[menuNoteIndex % menuMusicConfig.notes.length];
                        mainSynth.triggerAttackRelease(note, "4n", time, 0.3);
                        menuNoteIndex++;
                    }, menuMusicConfig.tempo); 


                    // 2. Setup Tone.js Players for One-Shot MP3s 
                    for (const soundName in LOCAL_SOUND_CONFIG) {
                        const filePath = LOCAL_SOUND_CONFIG[soundName];
                        if (soundName !== 'backgroundMusic') {
                            const player = new Tone.Player(filePath, () => {
                                // Loaded successfully
                            });
                            player.onerror = () => {
                                console.warn(`Failed to load MP3 for ${soundName}: ${filePath}. Falling back to Tone.js.`);
                                mp3LoadingFailed[soundName] = true;
                            };
                            soundPlayers[soundName] = player.toDestination(); 
                        }
                    }
                    
                    // 3. Setup Tone.js Player for Background Music MP3 (Looping)
                    const musicPath = LOCAL_SOUND_CONFIG.backgroundMusic;
                    if (musicPath) {
                        backgroundPlayer = new Tone.Player({
                            url: musicPath,
                            loop: true,
                            volume: -6 
                        }, () => {
                            console.log("MP3 Background Music loaded.");
                        }).toDestination();

                        backgroundPlayer.onerror = () => {
                            console.warn(`Failed to load MP3 for backgroundMusic: ${musicPath}. Falling back to Tone.js loop.`);
                            mp3LoadingFailed.backgroundMusic = true;
                        };
                    }

                    audioContextInitialized = true;
                    // Start menu music right away after initialization if sound is enabled
                    if (isSoundEnabled) {
                        startMenuMusic(); 
                    }
                });
            }
            
            // --- Fireball Class (Unchanged) ---
            class Fireball {
                constructor(x, y, vx, vy, startTime) {
                    this.x = x;
                    this.y = y;
                    this.vx = vx;
                    this.vy = vy;
                    this.startTime = startTime;
                    this.element = this.createElement();
                    this.isMoving = false;
                    this.isBoosted = false; // Used for both platform and F-F boost
                    this.baseSpeed = Math.sqrt(vx * vx + vy * vy); 
                }

                createElement() {
                    const $el = $fireballTemplate.clone().removeAttr('id').removeClass('hidden').addClass('fireball');
                    $el.find('svg').css({ width: FIREBALL_SIZE + 'px', height: FIREBALL_SIZE + 'px' });
                    $el.appendTo($gameContainer);
                    return $el;
                }

                updateDOM() {
                    const now = Date.now();
                    if (now >= this.startTime) {
                        this.isMoving = true;
                        this.element.css({ opacity: 1 });
                    } else {
                        this.element.css({ opacity: 0.3 }); 
                    }

                    this.element.css({
                        left: this.x + 'px',
                        bottom: this.y + 'px',
                        width: FIREBALL_SIZE + 'px',
                        height: FIREBALL_SIZE + 'px',
                    });
                }

                destroy() {
                    this.element.remove();
                }

                updateVelocityMagnitude(newSpeed) {
                    const currentMagnitude = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (currentMagnitude > 0) {
                        const ratio = newSpeed / currentMagnitude;
                        this.vx *= ratio;
                        this.vy *= ratio;
                    } else {
                        // Fallback in case of zero velocity, shouldn't happen with baseSpeed > 0
                        this.vx = newSpeed * (Math.random() < 0.5 ? 1 : -1);
                        this.vy = newSpeed * (Math.random() < 0.5 ? 1 : -1);
                    }
                    // Do NOT update baseSpeed here. baseSpeed is the *unboosted* speed, updated only by speedUpFireballs.
                    // this.baseSpeed = newSpeed; 
                }
            }
            
            // --- Utilities & Display (Mostly Unchanged) ---

            function loadTopScore() {
                const storedScore = localStorage.getItem(STORAGE_KEY);
                return storedScore ? parseFloat(storedScore) : 0.00;
            }

            function updateTopScore(newScore) {
                const currentTopScore = loadTopScore();
                
                if (newScore > currentTopScore) {
                    localStorage.setItem(STORAGE_KEY, newScore.toFixed(2));
                    $topScoreDisplay.text('Top: ' + newScore.toFixed(2) + 's');
                    
                    if (!topScoreAchievedDuringGame) {
                        playSound('maxScore');
                        topScoreAchievedDuringGame = true;
                    }
                }
            }

            function updateTripleJumpDisplay() {
                const now = Date.now();
                const elapsed = now - lastTripleJumpTime;
                const remainingTime = Math.max(0, TRIPLE_JUMP_COOLDOWN_MS - elapsed);
                
                if (remainingTime > 0) {
                    const seconds = (remainingTime / 1000).toFixed(1);
                    $tripleJumpDisplay.text(`TJ Cooldown: ${seconds}s`).removeClass('text-yellow-400').addClass('text-red-400');
                    if (!tjCooldownTimer) {
                        tjCooldownTimer = setInterval(updateTripleJumpDisplay, 100);
                    }
                } else {
                    $tripleJumpDisplay.text(`TJ Ready!`).removeClass('text-red-400').addClass('text-yellow-400');
                    if (tjCooldownTimer) {
                        clearInterval(tjCooldownTimer);
                        tjCooldownTimer = null;
                    }
                }
            }
            
            function populateFireballDropdown() {
                let optionsHtml = '';
                for (let i = MIN_FIREBALLS; i <= MAX_FIREBALLS; i++) {
                    optionsHtml += `<option value="${i}">${i}</option>`;
                }
                $fireballSelect.html(optionsHtml);
                $fireballSelect.val(5); 
            }

            function updatePlatformWarning(difficulty) { 
                let message = '';
                let className = '';
                if (difficulty === 'easy') {
                    message = 'EASY: No platforms.';
                    className = 'text-green-300';
                } else if (difficulty === 'medium') {
                    message = 'MEDIUM: 1 moving platform near the top (50px margin).';
                    className = 'text-yellow-300';
                } else if (difficulty === 'hard') {
                    message = 'HARD: 3 randomly moving platforms stacked from the top!';
                    className = 'text-red-300';
                }
                $platformWarning.text(message).removeClass().addClass('mt-2 text-sm font-semibold ' + className);
            }


            // --- Score Logic (Unchanged) ---
            function startScoring() {
                if (scoreInterval) clearInterval(scoreInterval);
                currentScore = 0;
                topScoreAchievedDuringGame = false; 
                scoreInterval = setInterval(() => {
                    currentScore += 0.01; 
                    $currentScoreDisplay.text('Time: ' + currentScore.toFixed(2) + 's');
                    updateTopScore(currentScore);
                }, 10); 
            }

            function stopScoring() {
                if (scoreInterval) {
                    clearInterval(scoreInterval);
                    scoreInterval = null;
                }
            }
            // --- End Score Logic ---

            function updateHeartDisplay() {
                let html = '';
                const fullHeartSvg = `<svg class="heart-icon" viewBox="0 0 24 24" fill="#E53E3E" stroke="#A03232" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;
                const emptyHeartSvg = `<svg class="heart-icon empty-heart" viewBox="0 0 24 24" fill="none" stroke="#A03232" xmlns="http://www.w3.org/2000/svg"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>`;

                for (let i = 0; i < MAX_LIVES; i++) {
                    html += i < koopaLives ? fullHeartSvg : emptyHeartSvg;
                }
                
                $('#lives-display').html(html);
            }

            // --- Ground Parallax (Unchanged) ---
            function updateGroundPosition(direction) {
                const PARALLAX_LIMIT = groundMaxMovement; 
                
                if (direction === 1) { 
                    groundOffsetX = Math.max(groundOffsetX - PARALLAX_STEP, -PARALLAX_LIMIT);
                } else if (direction === -1) { 
                    groundOffsetX = Math.min(groundOffsetX + PARALLAX_STEP, 0); 
                }

                $gameGround.css('left', groundOffsetX + 'px');
            }

            // --- Fullscreen Toggle (Unchanged) ---
            function toggleFullscreen() {
                playUiClick();
                const element = document.documentElement; 
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else if (element.requestFullscreen) {
                    element.requestFullscreen().catch(err => {
                        console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                    });
                }
            }

            // --- Game Flow ---
            
            function startHealing() {
                stopHealing(); 
                healInterval = setInterval(() => {
                    if (koopaLives < MAX_LIVES) {
                        koopaLives++;
                        updateHeartDisplay();
                    }
                }, HEAL_INTERVAL_MS);
            }

            function stopHealing() {
                if (healInterval) {
                    clearInterval(healInterval);
                    healInterval = null;
                }
            }

            function startTimers() {
                speedUpInterval = setInterval(speedUpFireballs, SPEED_INTERVAL_MS);
                duplicationInterval = setInterval(duplicateFireball, DUPLICATION_INTERVAL_MS);
                startHealing(); 
            }

            function stopTimers() {
                if (speedUpInterval) clearInterval(speedUpInterval);
                if (duplicationInterval) clearInterval(duplicationInterval);
                stopHealing();
                speedUpInterval = null;
                duplicationInterval = null;
            }
            
            function updateDimensions() {
                gameContainerWidth = $gameContainer.width();
                gameContainerHeight = $gameContainer.height();

                const newGroundWidth = gameContainerWidth + GROUND_EXTRA_WIDTH;
                groundMaxMovement = GROUND_EXTRA_WIDTH; 

                $gameGround.css('width', newGroundWidth + 'px');
                
                // NEW: Calculate and set pipe position
                pipe.x = (gameContainerWidth / 2) - (PIPE_WIDTH / 2);
                pipe.y = GROUND_HEIGHT; // Pipe sits on the ground
                pipe.width = PIPE_WIDTH;
                pipe.height = PIPE_HEIGHT;
                pipe.rimHeight = PIPE_RIM_HEIGHT; // Used for Koopa landing check

                $gamePipe.css({
                    left: pipe.x + 'px',
                    width: pipe.width + 'px'
                });

                resetKoopaPosition();
                populateFireballDropdown();
            }

            function resetKoopaPosition() {
                gameContainerWidth = $gameContainer.width(); 

                koopaX = (gameContainerWidth / 2) - (PLAYER_WIDTH / 2);
                groundOffsetX = 0; 
                jumpsCompleted = 0; 
                currentFlipState = 0; 
                
                // Reset move speeds and timestamps
                currentLeftMoveStep = MOVE_STEP;
                currentRightMoveStep = MOVE_STEP;
                lastMoveLeftTime = 0; 
                lastMoveRightTime = 0; 
                
                // Reset touch state
                touchHeld = false;
                touchDirection = 0;

                updateTripleJumpDisplay();

                $koopa.css({
                    left: koopaX + 'px',
                    bottom: GROUND_HEIGHT + 'px',
                    opacity: 1
                }).removeClass('koopa-invincible koopa-flip'); 

                $gameGround.css('left', '0px');
            }
            
            // --- Fireball & Speed Logic (Unchanged) ---

            function createFireball(delay = 0) {
                gameContainerWidth = $gameContainer.width();
                gameContainerHeight = $gameContainer.height();
                
                const koopaCenterX = koopaX + PLAYER_WIDTH / 2;
                const koopaCurrentY = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT;
                const koopaCenterY = koopaCurrentY + PLAYER_HEIGHT / 2; 

                const minFireballY = GROUND_HEIGHT;
                const maxFireballY = gameContainerHeight - FIREBALL_SIZE;
                const maxFireballX = gameContainerWidth - FIREBALL_SIZE;
                
                let fx, fy, distance;

                let attempts = 0;
                do {
                    fx = Math.random() * maxFireballX;
                    fy = Math.random() * (maxFireballY - minFireballY) + minFireballY;

                    const fireballCenterX = fx + FIREBALL_SIZE / 2;
                    const fireballCenterY = fy + FIREBALL_SIZE / 2;

                    distance = Math.sqrt(
                        Math.pow(fireballCenterX - koopaCenterX, 2) + 
                        Math.pow(fireballCenterY - koopaCenterY, 2)
                    );
                    attempts++;
                    if (attempts > 50) break; 
                } while (distance < MIN_START_DISTANCE);

                let vx = currentSpeed * (Math.random() < 0.5 ? 1 : -1);
                let vy = currentSpeed * (Math.random() < 0.5 ? 1 : -1);

                const startTime = Date.now() + delay;

                const newFireball = new Fireball(fx, fy, vx, vy, startTime);
                fireballs.push(newFireball);
            }

            function duplicateFireball() {
                createFireball(DUPLICATION_DELAY_MS);
            }

            function speedUpFireballs() {
                currentSpeed += SPEED_INCREASE_FACTOR; 

                fireballs.forEach(fb => {
                    // Update the *unboosted* base speed
                    fb.baseSpeed = currentSpeed; 
                    
                    if (fb.isMoving) {
                        // Calculate new magnitude based on the new base speed, maintaining boost state
                        const magnitude = fb.isBoosted ? 
                                          fb.baseSpeed * PLATFORM_SPEED_MULTIPLIER : 
                                          fb.baseSpeed;
                        fb.updateVelocityMagnitude(magnitude);
                    }
                });
            }
            
            // --- Damage & Collision Logic ---

            function takeDamage() {
                const now = Date.now();
                if (now - lastDamageTime < DAMAGE_COOLDOWN_MS) {
                    return false;
                }
                
                koopaLives--;
                updateHeartDisplay();
                lastDamageTime = now;
                
                playSound('koopaDamage'); 
                
                $koopa.addClass('koopa-invincible');
                setTimeout(() => {
                    $koopa.removeClass('koopa-invincible');
                }, DAMAGE_COOLDOWN_MS);

                if (koopaLives <= 0) {
                    gameOver();
                }
                return true;
            }
            
            function checkCollision(fireball) {
                const koopaCurrentY = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT; 

                const kLeft = koopaX + COLLISION_BUFFER;
                const kRight = koopaX + PLAYER_WIDTH - COLLISION_BUFFER;
                const kBottom = koopaCurrentY + COLLISION_BUFFER; 
                const kTop = koopaCurrentY + PLAYER_HEIGHT - COLLISION_BUFFER; 

                const fLeft = fireball.x;
                const fRight = fireball.x + FIREBALL_SIZE;
                const fBottom = fireball.y;
                const fTop = fireball.y + FIREBALL_SIZE;

                const overlapX = kLeft < fRight && kRight > fLeft;
                const overlapY = kBottom < fTop && kTop > fBottom;

                return overlapX && overlapY;
            }

            function checkFireballCollisions() {
                const fireballsToUpdate = fireballs.filter(fb => fb.isMoving);

                for (let i = 0; i < fireballsToUpdate.length; i++) {
                    for (let j = i + 1; j < fireballsToUpdate.length; j++) {
                        const fb1 = fireballsToUpdate[i];
                        const fb2 = fireballsToUpdate[j];

                        // Simple Axis-Aligned Bounding Box (AABB) collision check
                        const overlapX = fb1.x < fb2.x + FIREBALL_SIZE && fb1.x + FIREBALL_SIZE > fb2.x;
                        const overlapY = fb1.y < fb2.y + FIREBALL_SIZE && fb1.y + FIREBALL_SIZE > fb2.y;

                        if (overlapX && overlapY) {
                            
                            // Calculate relative center positions
                            const fb1CenterX = fb1.x + FIREBALL_SIZE / 2;
                            const fb2CenterX = fb2.x + FIREBALL_SIZE / 2;
                            const dx = fb1CenterX - fb2CenterX; 
                            const dy = fb1.y - fb2.y;

                            // --- Custom Logic: fb1 hits fb2 from behind, and fb2 is moving down ---
                            
                            let fb2_should_boost = false;
                            
                            // Condition: fb2 is moving downward
                            const fb2_is_downward = fb2.vy < 0; 
                            
                            // Condition: fb1 is "behind" fb2 (hitting the side fb2 is moving away from)
                            const isCollisionFromBehind_fb2 = 
                                (dx < 0 && fb2.vx > 0) || // fb1 is left of fb2, fb2 is moving right
                                (dx > 0 && fb2.vx < 0);  // fb1 is right of fb2, fb2 is moving left

                            if (fb2_is_downward && isCollisionFromBehind_fb2) {
                                // Apply user's custom logic to fb2
                                fb2.updateVelocityMagnitude(fb2.baseSpeed * FIREBALL_FIREBALL_BOOST_MULTIPLIER);
                                fb2.isBoosted = true; 
                                
                                // Set horizontal trajectory (right if hit object (fb1) is at the left side, otherwise left)
                                if (dx < 0) { // fb1 is left of fb2 (hit from left side)
                                    fb2.vx = Math.abs(fb2.vx); // Move right
                                } else { // fb1 is right of fb2 (hit from right side)
                                    fb2.vx = -Math.abs(fb2.vx); // Move left
                                }
                                
                                // Keep vertical direction downward
                                fb2.vy = -Math.abs(fb2.vy);
                                fb2_should_boost = true;
                            } 

                            // --- Custom Logic: fb2 hits fb1 from behind, and fb1 is moving down ---
                            
                            let fb1_should_boost = false;
                            
                            // Condition: fb1 is moving downward
                            const fb1_is_downward = fb1.vy < 0; 
                            
                            // Condition: fb2 is "behind" fb1 
                            const isCollisionFromBehind_fb1 = 
                                (dx > 0 && fb1.vx > 0) || // fb2 is right of fb1, fb1 is moving right
                                (dx < 0 && fb1.vx < 0);  // fb2 is left of fb1, fb1 is moving left

                            if (fb1_is_downward && isCollisionFromBehind_fb1) {
                                // Apply user's custom logic to fb1
                                fb1.updateVelocityMagnitude(fb1.baseSpeed * FIREBALL_FIREBALL_BOOST_MULTIPLIER);
                                fb1.isBoosted = true; 
                                
                                // Set horizontal trajectory (right if hit object (fb2) is at the left side, otherwise left)
                                // Note: dx is fb1.x - fb2.x. If dx > 0, fb1 is right of fb2, so fb2 is on the left.
                                if (dx > 0) { // fb2 is left of fb1 (hit from left side)
                                    fb1.vx = Math.abs(fb1.vx); // Move right
                                } else { // fb2 is right of fb1 (hit from right side)
                                    fb1.vx = -Math.abs(fb1.vx); // Move left
                                }
                                
                                // Keep vertical direction downward
                                fb1.vy = -Math.abs(fb1.vy);
                                fb1_should_boost = true;
                            }


                            // --- Default Bounce Logic (Only if neither received a custom boost) ---
                            if (!fb1_should_boost && !fb2_should_boost) {
                                // Default bounce for all other collision types
                                fb1.vx *= -1;
                                fb1.vy *= -1;
                                fb2.vx *= -1;
                                fb2.vy *= -1;
                            } else {
                                // For boosted collisions, just ensure the non-boosted one reverses its trajectory 
                                // to move away from the boosted one, simplifying the interaction.
                                if (fb1_should_boost && !fb2_should_boost) {
                                    fb2.vx = (fb2.x < fb1.x) ? -Math.abs(fb2.vx) : Math.abs(fb2.vx); // push away
                                    fb2.vy *= -1;
                                }
                                if (fb2_should_boost && !fb1_should_boost) {
                                    fb1.vx = (fb1.x < fb2.x) ? -Math.abs(fb1.vx) : Math.abs(fb1.vx); // push away
                                    fb1.vy *= -1;
                                }
                            }
                            
                            // Separate them slightly to prevent re-collision in the next frame
                            const distance = Math.sqrt(dx * dx + dy * dy) || 1; 
                            const separationDistance = 2; // Small separation value

                            fb1.x += (dx / distance) * separationDistance;
                            fb1.y += (dy / distance) * separationDistance;
                            fb2.x -= (dx / distance) * separationDistance;
                            fb2.y -= (dy / distance) * separationDistance;
                            
                            // Use platform bounce sound for impact
                            playSound('fireballPlatformBounce'); 
                        }
                    }
                }
            }


            function startWiggle() { 
                $gameContainer.addClass('wiggle-short');
                setTimeout(() => {
                    $gameContainer.removeClass('wiggle-short');
                }, WIGGLE_DURATION_MS); 
            }
            
            function createPlatformElement(width, height, x, yFromBottom) {
                const $el = $('<div class="game-platform"></div>');
                $el.css({
                    left: x + 'px',
                    bottom: yFromBottom + 'px', 
                    width: width + 'px',
                    height: height + 'px',
                }).appendTo($gameContainer);
                return $el;
            }
            
            // NEW: Function to check Koopa-Pipe landing collision (Top surface)
            function checkKoopaPipeLanding(koopaTargetY) {
                 const pipeTopY = pipe.y + pipe.height + pipe.rimHeight;

                 // Koopa's horizontal extent (with a small buffer)
                 const kLeft = koopaX + 5;
                 const kRight = koopaX + PLAYER_WIDTH - 5;
                 
                 // Pipe's horizontal extent
                 const pLeft = pipe.x;
                 const pRight = pipe.x + pipe.width;

                 const horizontalOverlap = kLeft < pRight && kRight > pLeft;
                 
                 if (horizontalOverlap) {
                     // Check if Koopa is currently falling (target Y is ground height)
                     // AND if the top of Koopa's head is above the pipe top
                     const koopaCurrentY = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT;
                     const koopaHeadY = koopaCurrentY + PLAYER_HEIGHT;
                     
                     // If Koopa is above the pipe and is trying to land below it (on the ground)
                     if (koopaHeadY > pipeTopY && koopaTargetY < pipeTopY) {
                         // Land Koopa on the pipe instead of the ground
                         return pipeTopY - PLAYER_HEIGHT;
                     }
                 }
                 return GROUND_HEIGHT; // Land on the ground
            }

            // -------------------------------------------------------------------
            // START: GAME LOOP 
            // -------------------------------------------------------------------
            function gameLoop() {
                if (!isPlaying) {
                    if (gameLoopInterval) clearInterval(gameLoopInterval);
                    return;
                }
                
                gameContainerWidth = $gameContainer.width();
                gameContainerHeight = $gameContainer.height();

                const maxFireballX = gameContainerWidth - FIREBALL_SIZE;
                const maxFireballY = gameContainerHeight - FIREBALL_SIZE;
                const minFireballY = GROUND_HEIGHT;
                
                let collisionDetected = false;
                let fireballsToKeep = []; 

                const koopaCurrentY = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT;
                
                // NEW: Koopa's landing logic should check if he's on the ground OR on the pipe.
                const pipeTopY = pipe.y + pipe.height + pipe.rimHeight;
                const pipeKoopaY = pipeTopY - PLAYER_HEIGHT;
                
                // If Koopa is at rest (within a small tolerance) on the ground or pipe, reset jumps
                if (Math.abs(koopaCurrentY - GROUND_HEIGHT) < 5 || 
                    (Math.abs(koopaCurrentY - pipeKoopaY) < 5 && koopaCurrentY > GROUND_HEIGHT)) {
                    jumpsCompleted = 0;
                }

                
                // --- 0.5. Continuous Koopa Movement Logic (KEYBOARD & TOUCH) ---
                if (keysHeld.left || (touchHeld && touchDirection === -1)) {
                    moveKoopa(-1);
                }
                if (keysHeld.right || (touchHeld && touchDirection === 1)) {
                    moveKoopa(1);
                }
                
                // -------------------------------------------------
                
                // --- 0. Platform Movement ---
                platforms.forEach(p => {
                    p.x += p.vx;
                    const platformMaxX = gameContainerWidth - p.width;
                    
                    if (p.x <= 0) {
                        p.vx = Math.abs(p.vx);
                        p.x = 0;
                    } else if (p.x >= platformMaxX) {
                        p.vx = -Math.abs(p.vx);
                        p.x = platformMaxX;
                    }
                    p.element.css('left', p.x + 'px');
                });

                // --- 1. Fireball-to-Fireball Collision Check ---
                checkFireballCollisions();

                fireballs.forEach(fb => {
                    fb.updateDOM(); 
                    
                    if (!fb.isMoving) {
                        fireballsToKeep.push(fb);
                        return; 
                    }

                    const prevY = fb.y; 
                    const prevTop = prevY + FIREBALL_SIZE; 
                    
                    let hitPlatformOrPipe = false; // Consolidated for sound
                    let hitGround = false;
                    let resetBoost = false;

                    // 2. Fireball Movement 
                    fb.x += fb.vx;
                    fb.y += fb.vy;

                    // 3. Fireball Wall Bounce Logic
                    if (fb.x <= 0) { fb.vx = Math.abs(fb.vx); fb.x = 0; } 
                    else if (fb.x >= maxFireballX) { fb.vx = -Math.abs(fb.vx); fb.x = maxFireballX; }

                    // Ground/Ceiling Bounce/Speed Reset Logic
                    if (fb.y <= minFireballY) { 
                        // Reset speed if fireball was boosted (by platform OR F-F collision)
                        if (fb.isBoosted) {
                            // Reset to the current unboosted speed (currentSpeed, not fb.baseSpeed as baseSpeed is now static)
                            fb.updateVelocityMagnitude(currentSpeed); 
                            fb.isBoosted = false;
                            startWiggle(); 
                            resetBoost = true; 
                        }
                        fb.vy = Math.abs(fb.vy); 
                        fb.y = minFireballY; 
                        hitGround = true; 
                    } 
                    else if (fb.y >= maxFireballY) { fb.vy = -Math.abs(fb.vy); fb.y = maxFireballY; }


                    // 4. Platform Collision Check
                    platforms.forEach(p => {
                        
                        const pBottom = p.y;
                        const pTop = p.y + p.height; 

                        const fLeft = fb.x;
                        const fRight = fb.x + FIREBALL_SIZE;
                        const fBottom = fb.y;
                        const fTop = fb.y + FIREBALL_SIZE;

                        const platformOverlapX = fRight > p.x && fLeft < p.x + p.width;
                        const platformOverlapY = fTop > pBottom && fBottom < pTop;

                        if (platformOverlapX && platformOverlapY) {
                            
                            hitPlatformOrPipe = true; 

                            // Only boost if not already boosted 
                            if (!fb.isBoosted) {
                                const newSpeed = fb.baseSpeed * PLATFORM_SPEED_MULTIPLIER;
                                fb.updateVelocityMagnitude(newSpeed);
                                fb.isBoosted = true;
                            }
                            
                            // Simple platform bounce logic
                            if (fb.vy < 0 && prevY >= pTop) {
                                fb.vy = Math.abs(fb.vy); 
                                fb.y = pTop; 
                            } 
                            else if (fb.vy > 0 && prevTop <= pBottom) {
                                fb.vy = -Math.abs(fb.vy); 
                                fb.y = pBottom - FIREBALL_SIZE; 
                            } 
                            else {
                                fb.vx *= -1; 
                            }
                        }
                    });
                    
                    // 5. Pipe Collision Check (Fireball)
                    // Define pipe collision area (including the rim)
                    const pipeBottom = pipe.y;
                    const pipeTop = pipe.y + pipe.height + pipe.rimHeight;
                    const pLeft = pipe.x;
                    const pRight = pipe.x + pipe.width;

                    const fLeft = fb.x;
                    const fRight = fb.x + FIREBALL_SIZE;
                    const fBottom = fb.y;
                    const fTop = fb.y + FIREBALL_SIZE;

                    const pipeOverlapX = fRight > pLeft && fLeft < pRight;
                    const pipeOverlapY = fTop > pipeBottom && fBottom < pipeTop;

                    if (pipeOverlapX && pipeOverlapY) {
                         
                         hitPlatformOrPipe = true;
                         
                         // Pipe collision logic: Fireball always reverses direction (bounce)
                         
                         // Determine collision side
                         const hitLeft = fb.vx > 0 && fRight > pLeft && fRight < pLeft + 5;
                         const hitRight = fb.vx < 0 && fLeft < pRight && fLeft > pRight - 5;
                         const hitTop = fb.vy < 0 && fTop > pipeTop && prevTop <= pipeTop;
                         const hitBottom = fb.vy > 0 && fBottom < pipeBottom && prevY >= pipeBottom;
                         
                         if (hitTop) { 
                             fb.vy = Math.abs(fb.vy); 
                             fb.y = pipeTop;
                         }
                         else if (hitBottom) { 
                             fb.vy = -Math.abs(fb.vy); 
                             fb.y = pipeBottom - FIREBALL_SIZE;
                         } 
                         else if (hitLeft || hitRight) { 
                             fb.vx *= -1;
                             // Separate fireball slightly from pipe edge to prevent sticking
                             if (hitLeft) fb.x = pLeft - FIREBALL_SIZE;
                             if (hitRight) fb.x = pRight;
                         }
                         // Fallback for corner cases (e.g., hit from inside/trapped)
                         else {
                            fb.vx *= -1;
                            fb.vy *= -1;
                         }
                         
                         // Note: Pipe collision does NOT boost the fireball speed, only redirects it.

                    }

                    // Play appropriate bounce sound
                    if (resetBoost) {
                        playSound('fireballBoostReset');
                    } else if (hitGround) {
                        playSound('fireballBounceGround');
                    } else if (hitPlatformOrPipe) {
                        // Use platform bounce sound for platforms AND pipe
                        playSound('fireballPlatformBounce'); 
                    }

                    // 6. Koopa Collision Check
                    if (checkCollision(fb)) {
                        collisionDetected = true;
                        fb.destroy(); 
                    } else {
                        fireballsToKeep.push(fb); 
                    }
                });
                
                fireballs = fireballsToKeep; 
                
                if (collisionDetected) {
                    takeDamage(); 
                }
                
                if (lastTripleJumpTime > 0) {
                    updateTripleJumpDisplay();
                }
            }
            // -------------------------------------------------------------------
            // END: GAME LOOP 
            // -------------------------------------------------------------------

            function wiggleMap() { 
                $gameContainer.addClass('wiggle');
                setTimeout(() => {
                    $gameContainer.removeClass('wiggle');
                }, 500);
            }

            function setupGame() {
                // Load Dev Mode state from local storage on startup
                const storedDevMode = localStorage.getItem(DEV_MODE_STORAGE_KEY);
                if (storedDevMode !== null) {
                    isDevMode = storedDevMode === 'true';
                }
                $devModeToggle.prop('checked', isDevMode);
                
                // Load sound state (as done before)
                const storedSoundState = localStorage.getItem(SOUND_STORAGE_KEY);
                if (storedSoundState !== null) {
                    isSoundEnabled = storedSoundState === 'true';
                }
                $soundToggle.prop('checked', isSoundEnabled); 

                updateDimensions();

                isPlaying = false;
                currentDifficulty = $difficultySelect.val();
                updatePlatformWarning(currentDifficulty);

                $gameOverMessage.text('Koopa Fireball Dodge');
                $overlay.show();
                $playButton.text('START');
                stopScoring();
                
                // Ensures menu music is playing (now respects isSoundEnabled and stops old music)
                if (audioContextInitialized) {
                    startMenuMusic(); 
                }
                
                koopaLives = INITIAL_LIVES; 
                updateHeartDisplay(); 
                
                if (tjCooldownTimer) {
                    clearInterval(tjCooldownTimer);
                    tjCooldownTimer = null;
                }
                lastTripleJumpTime = 0; 
                updateTripleJumpDisplay(); 
                
                populateFireballDropdown();
                
                resetKoopaPosition();
                $topScoreDisplay.text('Top: ' + loadTopScore().toFixed(2) + 's');
            }

            function initializePlatforms(difficulty) { 
                $('.game-platform').remove(); 
                platforms = []; 

                let numPlatforms = 0;
                if (difficulty === 'medium') numPlatforms = 1;
                if (difficulty === 'hard') numPlatforms = 3;

                for (let i = 0; i < numPlatforms; i++) {
                    let pX, pY, pVx;
                    
                    pX = Math.random() * (gameContainerWidth - PLATFORM_WIDTH);

                    if (difficulty === 'medium') {
                        pY = gameContainerHeight - PLATFORM_TOP_MARGIN - PLATFORM_HEIGHT;
                        pVx = Math.random() < 0.5 ? PLATFORM_SPEED : -PLATFORM_SPEED;
                    } else {
                        const verticalOffset = PLATFORM_TOP_MARGIN + (i * PLATFORM_VERTICAL_SPACING);
                        pY = gameContainerHeight - verticalOffset - PLATFORM_HEIGHT; 
                        pVx = Math.random() < 0.5 ? PLATFORM_SPEED : -PLATFORM_SPEED;
                    }

                    const $el = createPlatformElement(PLATFORM_WIDTH, PLATFORM_HEIGHT, pX, pY);

                    platforms.push({
                        id: i,
                        x: pX,
                        y: pY, 
                        vx: pVx,
                        width: PLATFORM_WIDTH,
                        height: PLATFORM_HEIGHT,
                        element: $el
                    });
                }
            }


            function startGame() {
                initializeAudioContext();
                playUiClick();

                if (isPlaying) return;

                isPlaying = true;
                $overlay.hide();
                currentSpeed = FIREBALL_BASE_SPEED; 
                currentDifficulty = $difficultySelect.val();
                
                const initialFireballCount = parseInt($fireballSelect.val(), 10) || 1; 

                koopaLives = INITIAL_LIVES;
                updateHeartDisplay();
                
                lastTripleJumpTime = 0; 
                jumpsCompleted = 0; 
                updateTripleJumpDisplay();
                resetKoopaPosition();

                initializePlatforms(currentDifficulty); 

                fireballs.forEach(fb => fb.destroy());
                fireballs = [];
                
                for (let i = 0; i < initialFireballCount; i++) {
                    createFireball(INITIAL_FIREBALL_DELAY); 
                }

                startScoring();
                startTimers(); 
                startBackgroundMusic(); // Starts game music (if enabled), stopping menu music
                
                gameLoopInterval = setInterval(gameLoop, 1000 / 60);
            }

            function gameOver() {
                isPlaying = false;
                if (gameLoopInterval) clearInterval(gameLoopInterval);
                stopScoring();
                stopTimers();
                
                // Switch music back to menu state
                stopAllMusic(); 
                startMenuMusic(); // Start menu music (if sound is still enabled)
                
                playSound('gameOver'); 
                
                if (tjCooldownTimer) clearInterval(tjCooldownTimer);
                tjCooldownTimer = null;

                wiggleMap();

                $koopa.css('opacity', 0.5).removeClass('koopa-invincible'); 
                fireballs.forEach(fb => fb.element.css('opacity', 0.5));

                $gameOverMessage.text('GAME OVER');
                $overlay.show();
                $playButton.text('PLAY AGAIN');
                
                updatePlatformWarning($difficultySelect.val()); 
            }

            // -------------------------------------------------------------------
            // NEW: KOOPA PIPE SIDE COLLISION CHECK
            // -------------------------------------------------------------------
            function isKoopaPipeSideCollision(nextX, direction) {
                // Ignore collision if Dev Mode is ON
                if (isDevMode) return false; 
                
                const koopaCurrentY = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT; 
                const pipeTopY = pipe.y + pipe.height + pipe.rimHeight;

                // 1. Vertical Check: Koopa must be on the ground or below the pipe's top rim
                if (koopaCurrentY + PLAYER_HEIGHT > pipeTopY) {
                    // Koopa is jumping over or is currently on top of the pipe, no side collision needed.
                    return false;
                }
                
                // 2. Horizontal Proximity Check (Koopa's next position)
                const kNextLeft = nextX;
                const kNextRight = nextX + PLAYER_WIDTH;
                const pLeft = pipe.x;
                const pRight = pipe.x + pipe.width;

                // Check for collision with the LEFT side of the pipe (Koopa moving Right)
                if (direction === 1) {
                    // Koopa's right side passes the pipe's left side (pLeft), but Koopa's left side hasn't passed it yet.
                    if (kNextRight > pLeft && koopaX + PLAYER_WIDTH <= pLeft) {
                         // Check if Koopa's left side would be inside the pipe boundary
                         if (kNextLeft < pRight) {
                             return true;
                         }
                    }
                }
                
                // Check for collision with the RIGHT side of the pipe (Koopa moving Left)
                else if (direction === -1) {
                    // Koopa's left side passes the pipe's right side (pRight), but Koopa's right side hasn't passed it yet.
                    if (kNextLeft < pRight && koopaX >= pRight) {
                         // Check if Koopa's right side would be inside the pipe boundary
                         if (kNextRight > pLeft) {
                             return true;
                         }
                    }
                }

                return false;
            }


            // -------------------------------------------------------------------
            // moveKoopa FUNCTION (Updated with Pipe Side Collision)
            // -------------------------------------------------------------------

            function moveKoopa(direction) {
                if (!isPlaying) return;

                // Use the globally determined move step
                let moveStep = (direction === -1) ? currentLeftMoveStep : currentRightMoveStep;
                
                if (direction === -1) {
                    currentFlipState = 1;
                    $koopa.addClass('koopa-flip');
                } else if (direction === 1) {
                    currentFlipState = 0;
                    $koopa.removeClass('koopa-flip');
                }

                let nextX = koopaX + (direction * moveStep);
                const maxKoopaX = gameContainerWidth - PLAYER_WIDTH;
                let oldKoopaX = koopaX;
                
                // 1. Koopa Pipe Collision Check
                if (isKoopaPipeSideCollision(nextX, direction)) {
                    // Stop Koopa just outside the pipe
                    if (direction === 1) {
                        nextX = pipe.x - PLAYER_WIDTH; // Stop at the left side
                    } else if (direction === -1) {
                        nextX = pipe.x + pipe.width; // Stop at the right side
                    }
                }


                // 2. Wall Collision Check
                koopaX = Math.max(0, Math.min(nextX, maxKoopaX));
                
                // 3. Update DOM and Parallax if position changed
                if (koopaX !== oldKoopaX) {
                    $koopa.css('left', koopaX + 'px');
                    
                    const nearLeftEdge = koopaX < 10 && direction === -1 && groundOffsetX === 0;
                    const nearRightEdge = koopaX > (maxKoopaX - 10) && direction === 1 && groundOffsetX === -groundMaxMovement;

                    if (!nearLeftEdge && !nearRightEdge) {
                        updateGroundPosition(direction);
                    }
                }
            }
            // -------------------------------------------------------------------


            function handleJump() {
                if (!isPlaying || jumpsCompleted >= MAX_JUMPS) return;
                
                const now = Date.now();
                const isTripleJumpAttempt = (jumpsCompleted === MAX_JUMPS - 1); 

                if (isTripleJumpAttempt && (now - lastTripleJumpTime < TRIPLE_JUMP_COOLDOWN_MS)) {
                    console.warn("Triple Jump on cooldown!");
                    return; 
                }

                if (isTripleJumpAttempt) {
                    lastTripleJumpTime = now; 
                    updateTripleJumpDisplay();
                }

                jumpsCompleted++; 
                playUiClick(); 

                $koopa.stop(true, false); 

                let currentBottom = parseFloat($koopa.css('bottom')) || GROUND_HEIGHT;
                
                let jumpMultiplier = 1.0;
                if (jumpsCompleted === 2) jumpMultiplier = 1.2;
                if (jumpsCompleted === 3) jumpMultiplier = 1.5; 

                const jumpHeight = JUMP_BASE_HEIGHT * jumpMultiplier;
                
                let newBottom = currentBottom + jumpHeight;

                const maxPossibleBottom = (gameContainerHeight - PLAYER_HEIGHT) * MAX_JUMP_RATIO;
                newBottom = Math.min(newBottom, maxPossibleBottom);
                
                $koopa.animate({ 
                    bottom: newBottom + 'px' 
                }, JUMP_DURATION_UP, 'easeOutQuad', function() {
                    
                    // NEW: Determine the correct landing spot (ground or pipe)
                    const finalLandingY = checkKoopaPipeLanding(GROUND_HEIGHT);
                    
                    $koopa.animate({ 
                        bottom: finalLandingY + 'px' 
                    }, JUMP_DURATION_DOWN, 'easeInQuad', function() {
                        jumpsCompleted = 0; 
                    });
                });
            }


            // -------------------------------------------------------------------
            // KEYBOARD HANDLERS (Unchanged)
            // -------------------------------------------------------------------
            function handleKeyDown(e) {
                const key = e.key.toLowerCase();
                const now = Date.now();
                
                if (!isPlaying) {
                    if (key === ' ') {
                        e.preventDefault();
                        if (!$overlay.is(':hidden')) startGame();
                    }
                    return;
                }

                switch (key) {
                    case 'arrowleft':
                    case 'a': 
                        e.preventDefault();
                        // Double-tap boost check: If key is already down, or if key was pressed quickly after last move
                        if (keysHeld.left || (now - lastMoveLeftTime < DOUBLE_TAP_INTERVAL_MS && !keysHeld.left)) {
                            currentLeftMoveStep = MOVE_STEP_BOOST;
                        } else {
                            currentLeftMoveStep = MOVE_STEP;
                        }
                        lastMoveLeftTime = now;
                        keysHeld.left = true;
                        break;
                        
                    case 'arrowright':
                    case 'd': 
                        e.preventDefault();
                        // Double-tap boost check
                        if (keysHeld.right || (now - lastMoveRightTime < DOUBLE_TAP_INTERVAL_MS && !keysHeld.right)) {
                            currentRightMoveStep = MOVE_STEP_BOOST;
                        } else {
                            currentRightMoveStep = MOVE_STEP;
                        }
                        lastMoveRightTime = now;
                        keysHeld.right = true;
                        break;
                        
                    case ' ': 
                    case 'w':
                        e.preventDefault();
                        handleJump();
                        break;
                }
            }

            function handleKeyUp(e) {
                const key = e.key.toLowerCase();
                if (!isPlaying) return;

                switch (key) {
                    case 'arrowleft':
                    case 'a': 
                        keysHeld.left = false;
                        currentLeftMoveStep = MOVE_STEP; // Reset speed on release
                        break;
                    case 'arrowright':
                    case 'd': 
                        keysHeld.right = false;
                        currentRightMoveStep = MOVE_STEP; // Reset speed on release
                        break;
                }
            }
            // -------------------------------------------------------------------
            
            // -------------------------------------------------------------------
            // TOUCH HANDLERS MODIFIED FOR SIMULTANEOUS MOVEMENT/JUMP (Unchanged)
            // -------------------------------------------------------------------
            function handleTouchStart(e) {
                // Check if target is a UI element
                if (!isPlaying || $(e.target).closest('#play-button, #fireball-select, #difficulty-select, #sound-toggle-container, #game-overlay, #fullscreen-btn').length) return;
                
                e.preventDefault();

                // Use changedTouches for multi-touch (mobile), fallback for mousedown (desktop)
                const touches = e.originalEvent.changedTouches || [e.originalEvent]; 

                const containerOffset = $gameContainer.offset();
                const containerHeight = $gameContainer.height();
                const containerWidth = $gameContainer.width();
                const halfHeight = containerHeight / 2;
                const halfWidth = containerWidth / 2;
                const now = Date.now();
                
                let jumpTriggered = false; 
                let movementAttempted = false; 
                let newTouchDirection = 0;

                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];
                    
                    // Determine clientX/clientY based on touch object structure
                    const clientX = touch.clientX || (touch.originalEvent && touch.originalEvent.clientX);
                    const clientY = touch.clientY || (touch.originalEvent && touch.originalEvent.clientY);

                    if (clientX === undefined || clientY === undefined) continue;

                    const clickX = clientX - containerOffset.left;
                    const clickY = clientY - containerOffset.top; 

                    if (clickY < halfHeight) {
                        // Jump (Top Half) - Trigger a jump, but do not stop movement
                        if (!jumpTriggered) {
                            handleJump();
                            jumpTriggered = true;
                        }
                    } else {
                        // Movement (Bottom Half) - Set up continuous hold
                        movementAttempted = true;
                        touchHeld = true; // Set touchHeld to true immediately
                        
                        if (clickX < halfWidth) {
                            newTouchDirection = -1; // Left
                            // Touch Double-tap logic for boost
                            currentLeftMoveStep = (now - lastMoveLeftTime < DOUBLE_TAP_INTERVAL_MS) ? MOVE_STEP_BOOST : MOVE_STEP;
                            lastMoveLeftTime = now;
                        } else {
                            newTouchDirection = 1; // Right
                            // Touch Double-tap logic for boost
                            currentRightMoveStep = (now - lastMoveRightTime < DOUBLE_TAP_INTERVAL_MS) ? MOVE_STEP_BOOST : MOVE_STEP;
                            lastMoveRightTime = now;
                        }
                        // The last touch to hit the movement zone sets the current direction
                        touchDirection = newTouchDirection;
                    }
                }
            }
            
            function handleTouchEnd(e) {
                const touches = e.originalEvent.touches; // Current active touches *after* the finger lift
                
                if (!touches || touches.length === 0) {
                    // No touches left on screen (mouse up or last finger lifted)
                    touchHeld = false;
                    touchDirection = 0;
                    currentLeftMoveStep = MOVE_STEP;
                    currentRightMoveStep = MOVE_STEP;
                    return;
                }
                
                // If there are still touches, check if any of them are in the movement zone.
                const containerOffset = $gameContainer.offset();
                const containerHeight = $gameContainer.height();
                const halfHeight = containerHeight / 2;
                const halfWidth = $gameContainer.width() / 2;
                
                let movementTouchRemaining = false;
                let activeMovementDirection = 0;

                for (let i = 0; i < touches.length; i++) {
                    const touch = touches[i];
                    const clientY = touch.clientY;
                    const clientX = touch.clientX;
                    const clickY = clientY - containerOffset.top; 

                    if (clickY >= halfHeight) {
                        // A finger is still in the movement zone
                        movementTouchRemaining = true;
                        // Re-evaluate direction based on remaining touch (use the first one found)
                        activeMovementDirection = (clientX - containerOffset.left < halfWidth) ? -1 : 1; 
                        break; 
                    }
                }

                if (!movementTouchRemaining) {
                    // All remaining fingers are in the jump zone, or no fingers are left in the movement zone
                    touchHeld = false;
                    touchDirection = 0;
                    currentLeftMoveStep = MOVE_STEP;
                    currentRightMoveStep = MOVE_STEP;
                } else {
                    // A finger is still holding for movement. Maintain the state.
                    touchHeld = true;
                    touchDirection = activeMovementDirection;
                }
            }
            // -------------------------------------------------------------------
            
            // --- Initialization (Unchanged) ---

            function initEvents() {
                // Load states on startup (moved to setupGame to ensure consistency)
                // The calls to $soundToggle.prop and $devModeToggle.prop are now in setupGame().

                $(document).on('keydown', handleKeyDown);
                $(document).on('keyup', handleKeyUp); 

                // --- UI Sound Effects (Dropdowns/Buttons/Toggle) ---
                $difficultySelect.on('change', function() {
                    initializeAudioContext();
                    playUiClick();
                    updatePlatformWarning($(this).val());
                }).on('focus', function() { 
                    initializeAudioContext();
                    playUiHover();
                });
                
                $fireballSelect.on('change', function() {
                    initializeAudioContext();
                    playUiClick();
                }).on('focus', function() { 
                    initializeAudioContext();
                    playUiHover();
                });
                
                $playButton.on('mousedown', playUiClick).on('mouseover', playUiHover).on('click', startGame);
                $fullscreenBtn.on('mousedown', playUiClick).on('mouseover', playUiHover).on('click', toggleFullscreen);

                $soundToggle.on('change', function() {
                    initializeAudioContext();
                    isSoundEnabled = $(this).prop('checked');
                    localStorage.setItem(SOUND_STORAGE_KEY, isSoundEnabled);
                    
                    if (isSoundEnabled) {
                        if (!isPlaying) { 
                            startMenuMusic(); 
                        } else {
                            startBackgroundMusic();
                        }
                    } else {
                        stopAllMusic();
                    }
                }).on('focus', playUiHover);
                
                // NEW: Dev Mode Toggle Handler
                $devModeToggle.on('change', function() {
                    initializeAudioContext();
                    isDevMode = $(this).prop('checked');
                    localStorage.setItem(DEV_MODE_STORAGE_KEY, isDevMode);
                    playUiClick();
                    
                    if (isDevMode) {
                        console.warn("Developer Mode ON: Pipe side collision disabled.");
                    } else {
                        console.warn("Developer Mode OFF: Pipe side collision enabled.");
                    }
                }).on('focus', playUiHover);


                // --- Game Click/Touch Handlers for Continuous Movement/Jump ---
                // Listen for mousedown/touchstart on the game container to BEGIN continuous move/jump
                $gameContainer.on('mousedown touchstart', handleTouchStart); 
                
                // Listen for mouseup/touchend/touchcancel on the entire document to END continuous move
                $(document).on('mouseup touchend touchcancel', handleTouchEnd); 
                
                // Original dblclick logic for jump (kept as backup for old mice)
                $koopa.on('dblclick', handleJump); 
                
                // Initialize audio context on any click/touch
                $gameContainer.one('click touchstart', initializeAudioContext);

                $(window).on('resize', function() {
                    updateDimensions();
                    if (!isPlaying) {
                        resetKoopaPosition();
                    }
                }).trigger('resize');
            }

            $.easing.easeOutQuad = function (x, t, b, c, d) { return -c * (t /= d) * (t - 2) + b; };
            $.easing.easeInQuad = function (x, t, b, c, d) { return c * (t /= d) * t + b; };

            // Initial setup
            setupGame();
            initEvents();

        });
    </script>
</head>
<body>
    
    <div id="scoreboard">
        <div class="flex items-center gap-2">
            <div id="lives-display" class="flex items-center gap-1">
                </div>
        </div>
        
        <span id="current-score">Time: 0.00s</span>

        <div class="flex items-center">
            <span id="top-score">Top: 0.00s</span>
            <span id="triple-jump-cooldown" class="ml-4 text-red-400 font-normal">TJ Ready!</span>
            <button id="fullscreen-btn" aria-label="Toggle Fullscreen" class="p-1">
                 <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3v3a2 2 0 0 1-2 2H3m3 8H3m3-8V3m0 0l-3 3m3 0H3m18 0V3m-3 3h3m0 0l-3-3m3 3V3"/></svg>
            </button>
        </div>
    </div>

    <div id="game-container">

        <div id="game-overlay">
             <h1 id="game-over-message" class="text-3xl font-bold">Koopa Fireball Dodge</h1>
             
             <div class="flex flex-col items-center justify-center gap-4 mt-4 md:flex-row">
                 
                 <div class="flex items-center gap-2">
                     <label for="difficulty-select" class="text-white font-medium">Difficulty:</label>
                     <select id="difficulty-select" class="p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-orange">
                         <option value="easy">Easy</option>
                         <option value="medium" selected>Medium</option>
                         <option value="hard">Hard</option>
                     </select>
                 </div>

                 <div class="flex items-center gap-2">
                     <label for="fireball-select" class="text-white font-medium">Starting Fireballs:</label>
                     <select id="fireball-select" class="p-2 rounded-lg bg-gray-700 text-white border border-gray-600 focus:outline-none focus:ring-2 focus:ring-brand-orange">
                         </select>
                 </div>
             </div>
             
             <div class="flex items-center gap-4 mt-4">
                <div class="flex items-center gap-2">
                    <label for="sound-toggle" class="text-white font-medium text-sm">Sound</label>
                    <label id="sound-toggle-container" class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="sound-toggle" checked class="sr-only peer">
                        <div class="w-9 h-5 bg-gray-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-brand-orange rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-brand-orange"></div>
                    </label>
                </div>
                
                <div class="flex items-center gap-2">
                    <label for="dev-mode-toggle" class="text-red-400 font-bold text-sm">Dev Mode (No Pipe Collide)</label>
                    <label id="dev-mode-toggle-container" class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="dev-mode-toggle" class="sr-only peer">
                        <div class="w-9 h-5 bg-gray-700 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-red-400 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-red-400"></div>
                    </label>
                </div>
            </div>

             <p id="platform-warning" class="mt-2 text-sm font-semibold text-yellow-300">MEDIUM: 1 moving platform near the top (50px margin).</p>

             <button id="play-button" class="mt-6">START</button>

             <p class="mt-8 text-sm font-medium">Controls: **Keyboard WASD/Arrows**. On Mobile/Touchscreen: **Bottom Half** of screen for **Left/Right Movement**, **Top Half** for **Jump**.</p>
             <div class="mt-4 text-sm font-semibold">
                <p class="text-yellow-300">Fireballs now destroy themselves on collision, speed up every 60s, and **WIGGLE** the screen when their boost resets!</p>
                <p class="text-red-300 font-bold">Triple Jump (3rd jump) has a **40-second cooldown**!</p>
                <p class="text-blue-300 font-bold">Platforms **triple the speed (3x multiplier)** of any fireball they hit until that fireball hits the ground!</p>
                <p class="text-red-400 font-bold mt-2">Aggressive Fireball Collision: Hitting a downward-moving fireball from behind doubles its speed and slams it in a new direction!</p>
                <p class="text-green-300 font-bold mt-2">UPDATED: **Multi-Touch Support**! Hold the bottom half to move continuously, and tap the top half with a second finger to jump simultaneously!</p>
                <p class="text-purple-300 font-bold mt-2">NEW: **Pipe**! Land on top for a height advantage, but watch out for fireballs bouncing off its sides! **Koopa cannot enter the pipe** from the sides when standing on the ground, unless **Dev Mode** is enabled.</p>
            </div>
        </div>

        <div id="game-ground"></div>
        
        <div id="game-pipe"></div>
        
        <div id="koopa" class="character">
            <svg viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="10" y="26" width="44" height="24" fill="#3CB371"/>
                <rect x="12" y="28" width="40" height="20" fill="#3CB371"/>
                <rect x="18" y="30" width="28" height="16" fill="#3CB371"/>
                <rect x="18" y="32" width="6" height="4" fill="#000000"/>
                <rect x="40" y="32" width="6" height="4" fill="#000000"/>
                <rect x="24" y="40" width="6" height="4" fill="#000000"/>
                <rect x="34" y="40" width="6" height="4" fill="#000000"/>

                <rect x="22" y="8" width="20" height="18" fill="#FFD700"/>

                <rect x="24" y="14" width="4" height="4" fill="#FFFFFF"/>
                <rect x="36" y="14" width="4" height="4" fill="#FFFFFF"/>
                <rect x="26" y="16" width="2" height="2" fill="#000000"/>
                <rect x="38" y="16" width="2" height="2" fill="#000000"/>

                <rect x="26" y="24" width="12" height="2" fill="#8B4513"/>

                <rect x="44" y="34" width="8" height="10" fill="#FFD700"/>
                <rect x="12" y="34" width="8" height="10" fill="#FFD700"/>

                <rect x="22" y="50" width="8" height ="6" fill="#8B4513"/>

                <rect x="34" y="50" width="8" height="6" fill="#8B4513"/>

                <rect x="22" y="6" width="20" height="2" fill="#8B4513"/>
            </svg>
        </div>

        <div id="fireball-template" class="fireball hidden" style="width: 15px; height: 15px;">
            <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="#FF4500"/>
                <circle cx="55" cy="45" r="20" fill="#FFD700"/>
                <circle cx="40" cy="60" r="10" fill="#FFFFFF" opacity="0.8"/>
            </svg>
        </div>
    </div>

</body>
</html>