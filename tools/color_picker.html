<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Rainbow Gradient Color Picker (HSV)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Load Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Load Inter Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    /* --- HSV Color Picker Styles --- */
    #saturationValuePad {
      position: relative;
      height: 350px;
      cursor: crosshair;
      border-radius: 12px;
    }
    #saturationOverlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to right, white, transparent);
      pointer-events: none;
      border-radius: inherit;
    }
    #valueOverlay {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(to top, black, transparent);
      pointer-events: none;
      border-radius: inherit;
    }
    
    /* Selector Circle */
    #selector {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 3px solid white;
      box-shadow: 0 0 0 1px #000, 0 0 10px rgba(0, 0, 0, 0.5);
      transform: translate(-50%, -50%);
      pointer-events: none;
      transition: border-color 0.1s ease;
    }

    /* Hue Slider Bar */
    #hueSlider {
      position: relative;
      height: 350px;
      width: 30px;
      background: linear-gradient(to bottom, 
          #f00 0%, #ff0 16.66%, #0f0 33.33%, 
          #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%);
      cursor: ns-resize;
      border-radius: 12px;
    }

    /* Hue Slider Thumb */
    #hueThumb {
      position: absolute;
      left: 50%;
      width: 40px;
      height: 12px;
      border: 3px solid #fff;
      background: currentColor;
      border-radius: 6px;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 0 1px #000, 0 0 8px rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }
    
    /* Toast Notification */
    #toast {
        visibility: hidden;
        min-width: 250px;
        background-color: #10b981;
        color: #fff;
        text-align: center;
        border-radius: 12px;
        padding: 16px;
        position: fixed;
        z-index: 1000;
        left: 50%;
        bottom: 30px;
        transform: translateX(-50%);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        font-weight: 600;
        opacity: 0;
        transition: opacity 0.5s, visibility 0.5s;
    }
    #toast.show {
        visibility: visible;
        opacity: 1;
    }

    /* --- PALETTE STYLES --- */
    .saved-color-box {
        position: relative;
        cursor: pointer;
        transition: transform 0.1s, border-color 0.3s, box-shadow 0.3s;
        border: 3px solid transparent; /* default border */
        background-color: #e5e7eb; /* default light gray for empty slot */
    }
    .saved-color-box:hover {
        transform: scale(1.05);
    }
    .saved-color-box.selected-slot {
        border-color: #9333ea; /* Tailwind purple-600 */
        box-shadow: 0 0 0 3px rgba(147, 51, 234, 0.7), 0 0 10px rgba(147, 51, 234, 0.4);
        transform: scale(1.05);
    }
    /* Delete button */
    .delete-btn {
        position: absolute;
        top: -6px;
        right: -6px;
        width: 18px;
        height: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ef4444; /* red-500 */
        color: white;
        border-radius: 9999px;
        font-size: 0.75rem;
        line-height: 1;
        opacity: 0;
        transition: opacity 0.2s;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .saved-color-box:hover .delete-btn {
        opacity: 1;
    }
  </style>
  
</head>
<body class="bg-gray-50 p-4 md:p-8 min-h-screen flex flex-col items-center">
  
  <div class="max-w-4xl w-full bg-white p-6 md:p-10 rounded-xl shadow-2xl">
    
    <h3 class="text-3xl font-bold text-gray-800 mb-6 text-center">
      Color Picker
    </h3>

    <!-- Color Preview -->
    <div id="colorPreview" class="h-16 w-full rounded-xl shadow-inner mb-6 border-4 border-gray-100 transition-colors duration-300"></div>

    <!-- Picker Area (Saturation/Value Pad + Hue Slider) -->
    <div class="flex gap-4 mb-8">
      
      <!-- Saturation/Value Pad (The main square) -->
      <div id="saturationValuePad" class="flex-1 bg-red-600">
        <div id="saturationOverlay"></div>
        <div id="valueOverlay"></div>
        <div id="selector"></div>
      </div>

      <!-- Hue Slider (The rainbow bar) -->
      <div id="hueSlider">
        <div id="hueThumb" style="color: rgb(255, 0, 0);"></div>
      </div>
    </div>

    <!-- Controls -->
    <div class="flex flex-col items-start md:flex-row md:justify-between md:items-center mb-6 border-t pt-4">
        <div id="selectedSlotInfo" class="text-lg font-semibold text-purple-700 mb-2 md:mb-0">
            Selected Slot: Slot 1 (Empty)
        </div>
        <button id="saveColorBtn" class="px-6 py-2 text-base w-full md:w-auto bg-purple-600 text-white font-medium rounded-lg hover:bg-purple-700 transition shadow-lg">
            Save Color to Selected Slot
        </button>
    </div>

    <!-- Color Values (HEX, RGB, HSL) -->
    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8">
      
      <!-- HEX -->
      <div class="flex flex-col items-center">
        <label for="hexInput" class="text-gray-600 font-medium mb-1">HEX</label>
        <input type="text" id="hexInput" class="border border-gray-300 rounded-lg p-2 w-full text-center text-sm font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition" readonly>
        <button class="copy-btn w-full mt-2 py-1.5 text-sm bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition shadow-md" data-target-id="hexInput">Copy HEX</button>
      </div>
      
      <!-- RGB -->
      <div class="flex flex-col items-center">
        <label for="rgbInput" class="text-gray-600 font-medium mb-1">RGB</label>
        <input type="text" id="rgbInput" class="border border-gray-300 rounded-lg p-2 w-full text-center text-sm font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition" readonly>
        <button class="copy-btn w-full mt-2 py-1.5 text-sm bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition shadow-md" data-target-id="rgbInput">Copy RGB</button>
      </div>
      
      <!-- HSL -->
      <div class="flex flex-col items-center">
        <label for="hslInput" class="text-gray-600 font-medium mb-1">HSL</label>
        <input type="text" id="hslInput" class="border border-gray-300 rounded-lg p-2 w-full text-center text-sm font-mono focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 transition" readonly>
        <button class="copy-btn w-full mt-2 py-1.5 text-sm bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition shadow-md" data-target-id="hslInput">Copy HSL</button>
      </div>
      
    </div>

    <!-- Saved Colors Palette -->
    <div class="mt-8 pt-4 border-t border-gray-200">
        <h4 class="text-xl font-semibold text-gray-700 mb-4">Saved Colors Palette (12 Slots - Uses Local Storage)</h4>
        <div id="paletteContainer" class="grid grid-cols-6 md:grid-cols-12 gap-3">
             <!-- Palette items will be rendered here -->
        </div>
    </div>
    
  </div>
  
  <!-- Toast Notification -->
  <div id="toast">Value copied to clipboard!</div>

  <script>
    const svPad = document.getElementById('saturationValuePad');
    const selector = document.getElementById('selector');
    const hueSlider = document.getElementById('hueSlider');
    const hueThumb = document.getElementById('hueThumb');
    const saveColorBtn = document.getElementById('saveColorBtn');
    const paletteContainer = document.getElementById('paletteContainer');
    const selectedSlotInfo = document.getElementById('selectedSlotInfo');
    
    const colorPreview = document.getElementById('colorPreview');
    const hexInput = document.getElementById('hexInput');
    const rgbInput = document.getElementById('rgbInput');
    const hslInput = document.getElementById('hslInput');
    const toast = document.getElementById('toast');
    
    // --- LOCAL STORAGE STATE ---
    const LOCAL_STORAGE_KEY = 'rainbowColorPaletteV3';
    // Initialize the palette with 12 null slots (null means empty)
    let savedColors = new Array(12).fill(null); 

    // Color State (HSV, current position, outputs, and selected slot)
    let colorState = { 
        h: 0, 
        s: 1, 
        v: 1, 
        currentHex: '#FF0000',
        currentRgb: 'rgb(255, 0, 0)',
        currentHsl: 'hsl(0, 100%, 50%)',
        selectedSlotIndex: 0 // Default to Slot 1
    };
    let isDraggingSV = false;
    let isDraggingHue = false;

    // --- LOCAL STORAGE FUNCTIONS ---

    /**
     * Loads the saved palette array from localStorage.
     */
    const loadPalette = () => {
        try {
            const data = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (data) {
                const loadedColors = JSON.parse(data);
                // Ensure we only load up to 12 slots and fill any gaps with null
                savedColors = loadedColors.slice(0, 12).concat(new Array(12 - loadedColors.length).fill(null));
            }
        } catch (e) {
            console.error("Error loading palette from localStorage:", e);
            window.showToast("Failed to load saved colors from storage.", 'red');
        }
    };

    /**
     * Saves the current palette array to localStorage.
     */
    const savePalette = () => {
        try {
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(savedColors));
        } catch (e) {
            console.error("Error saving palette to localStorage:", e);
            window.showToast("Failed to save changes to local storage.", 'red');
        }
    };

    /** Saves color data to the specified slot index (0-11) and updates storage. */
    const saveColorToPalette = (slotIndex, colorData) => {
        savedColors[slotIndex] = colorData;
        savePalette();
        renderPalette();
        window.showToast(`Color saved to Slot ${slotIndex + 1}!`, 'green');
    };

    /** Deletes the color from the specified slot index and updates storage. */
    const deleteColorFromPalette = (slotIndex) => {
        savedColors[slotIndex] = null; // Set slot to null (empty)
        savePalette();
        renderPalette();
        window.showToast(`Color removed from Slot ${slotIndex + 1}.`, 'red');
    };

    // --- UTILITY FUNCTIONS ---

    window.showToast = (message, type = 'green') => {
        toast.textContent = message;
        toast.style.backgroundColor = type === 'red' ? '#ef4444' : '#10b981';
        toast.classList.add("show");
        setTimeout(() => {
            toast.classList.remove("show");
        }, 3000);
    };

    const copyToClipboard = (targetId) => {
        const input = document.getElementById(targetId);
        try {
            input.select();
            input.setSelectionRange(0, 99999); 
            document.execCommand('copy');
            window.showToast(`${input.value} copied!`);
        } catch (err) {
            console.error('Copy failed:', err);
            window.showToast('Copy failed. Try manually.', 'red');
        }
    };
    
    // --- COLOR CONVERSION FUNCTIONS ---
    
    const hsvToRgb = (h, s, v) => {
        let r, g, b;
        h = h / 60;
        const i = Math.floor(h);
        const f = h - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    };

    const rgbToHex = (r, g, b) => {
        const componentToHex = (c) => {
            const hex = c.toString(16);
            return hex.length === 1 ? "0" + hex : hex;
        };
        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
    };

    const rgbToHsl = (r, g, b) => {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;
      let h = 0; let s = 0; let l = (max + min) / 2;

      if (diff !== 0) {
        s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);
        switch (max) {
          case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
          case g: h = (b - r) / diff + 2; break;
          case b: h = (r - g) / diff + 4; break;
        }
        h /= 6;
      }
      return `hsl(${Math.round(h * 360)}, ${Math.round(s * 100)}%, ${Math.round(l * 100)}%)`;
    };
    
    // --- UI & STATE UPDATES ---

    const updateSvPadBaseColor = () => {
        const baseRgb = hsvToRgb(colorState.h, 1, 1);
        svPad.style.backgroundColor = `rgb(${baseRgb.r}, ${baseRgb.g}, ${baseRgb.b})`;
        hueThumb.style.backgroundColor = `rgb(${baseRgb.r}, ${baseRgb.g}, ${baseRgb.b})`;
    };

    const updateSelectorPosition = (x, y) => {
        selector.style.left = `${x}px`;
        selector.style.top = `${y}px`;
    }

    const updateHueThumbPosition = (y) => {
        hueThumb.style.top = `${y}px`;
    }
    
    const updateColor = () => {
        const rgb = hsvToRgb(colorState.h, colorState.s, colorState.v);
        const hex = rgbToHex(rgb.r, rgb.g, rgb.b).toUpperCase();
        const rgbString = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        const hslString = rgbToHsl(rgb.r, rgb.g, rgb.b);
        
        // Update current color state
        colorState.currentHex = hex;
        colorState.currentRgb = rgbString;
        colorState.currentHsl = hslString;

        // Update UI elements
        colorPreview.style.backgroundColor = rgbString;
        hexInput.value = hex;
        rgbInput.value = rgbString;
        hslInput.value = hslString;
        
        // Ensure selector border contrasts with the color underneath
        const selectorBorderColor = colorState.v > 0.6 || colorState.s < 0.2 ? 'black' : 'white';
        selector.style.borderColor = selectorBorderColor;
    };
    
    /** Selects the palette slot for saving and updates the UI. */
    const selectSlot = (index) => {
        // Remove 'selected-slot' class from all palette items
        document.querySelectorAll('.saved-color-box').forEach(el => {
            el.classList.remove('selected-slot');
        });
        
        colorState.selectedSlotIndex = index;
        
        const newSlotElement = document.getElementById(`slot-${index}`);
        if (newSlotElement) {
            newSlotElement.classList.add('selected-slot');
            
            // Update the info box
            const colorData = savedColors[index];
            const status = colorData ? `Saved: ${colorData.hex}` : 'Empty';
            selectedSlotInfo.textContent = `Selected Slot: Slot ${index + 1} (${status})`;
        }
    };


    const handleSvUpdate = (event) => {
        const rect = svPad.getBoundingClientRect();
        let x = event.clientX - rect.left;
        let y = event.clientY - rect.top;

        x = Math.max(0, Math.min(x, rect.width));
        y = Math.max(0, Math.min(y, rect.height));

        colorState.s = x / rect.width; 
        colorState.v = 1 - (y / rect.height); 

        updateSelectorPosition(x, y);
        updateColor();
    };

    const handleHueUpdate = (event) => {
        const rect = hueSlider.getBoundingClientRect();
        let y = event.clientY - rect.top;

        y = Math.max(0, Math.min(y, rect.height));

        colorState.h = (y / rect.height) * 360;

        updateHueThumbPosition(y);
        updateSvPadBaseColor();
        updateColor();
    };

    const selectSavedColor = (color) => {
        // Extract HSL components
        const hslMatch = color.hsl.match(/hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/);
        if (hslMatch) {
            const h = parseInt(hslMatch[1]);
            const sPercent = parseInt(hslMatch[2]) / 100;
            const lPercent = parseInt(hslMatch[3]) / 100;
            
            colorState.h = h;
            
            const rect = svPad.getBoundingClientRect();

            // Approximate S and V from HSL (complex conversion, using heuristic for picker position)
            const V_numerator = lPercent + sPercent * Math.min(lPercent, 1 - lPercent);
            const V_denominator = lPercent === 0 ? 1 : 2 * lPercent;
            let vApprox = V_numerator / V_denominator;
            
            // Adjust saturation approximation
            let sApprox = lPercent === 1 ? 0 : 2 * (1 - lPercent / vApprox);
            
            vApprox = Math.max(0, Math.min(1, vApprox));
            sApprox = Math.max(0, Math.min(1, sApprox));
            
            colorState.v = vApprox;
            colorState.s = sApprox;
            
            updateHueThumbPosition((h / 360) * hueSlider.offsetHeight);
            updateSvPadBaseColor();
            updateSelectorPosition(
                colorState.s * rect.width, 
                (1 - colorState.v) * rect.height
            );
        }
        updateColor();
    };

    // --- PALETTE RENDERING ---

    const renderPalette = () => {
        paletteContainer.innerHTML = ''; // Clear existing
        
        savedColors.forEach((color, index) => {
            const box = document.createElement('div');
            box.id = `slot-${index}`;
            box.className = `saved-color-box w-full aspect-square rounded-lg shadow-md hover:shadow-lg transition-all`;
            
            const hasColor = color !== null;
            box.style.backgroundColor = hasColor ? color.rgb : ''; // Use CSS default for empty slot
            box.setAttribute('data-index', index);
            box.setAttribute('title', hasColor ? `${color.hex} | Slot ${index + 1}` : `Slot ${index + 1} (Empty)`);
            
            // Click to select slot for saving/deletion
            box.onclick = () => selectSlot(index);
            
            if (hasColor) {
                // Double-Click to select color in the main picker
                box.ondblclick = () => selectSavedColor(color); 
                
                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = `Delete Slot ${index + 1}`;
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteColorFromPalette(index);
                };
                box.appendChild(deleteBtn);
            }
            
            paletteContainer.appendChild(box);
        });
        
        // Ensure the correct slot is selected and displayed after rendering
        selectSlot(colorState.selectedSlotIndex);
    };


    // --- INITIALIZATION ---
    document.addEventListener('DOMContentLoaded', () => {
        
        // 1. Load data from local storage
        loadPalette();

        // 2. Set up event listeners for Picker
        svPad.addEventListener('mousedown', (e) => { e.preventDefault(); isDraggingSV = true; handleSvUpdate(e); });
        svPad.addEventListener('touchstart', (e) => { e.preventDefault(); isDraggingSV = true; handleSvUpdate(e.touches[0]); });
        
        hueSlider.addEventListener('mousedown', (e) => { e.preventDefault(); isDraggingHue = true; handleHueUpdate(e); });
        hueSlider.addEventListener('touchstart', (e) => { e.preventDefault(); isDraggingHue = true; handleHueUpdate(e.touches[0]); });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingSV) handleSvUpdate(e);
            else if (isDraggingHue) handleHueUpdate(e);
        });
        document.addEventListener('touchmove', (e) => {
            if (isDraggingSV) handleSvUpdate(e.touches[0]);
            else if (isDraggingHue) handleHueUpdate(e.touches[0]);
        });

        document.addEventListener('mouseup', () => { isDraggingSV = false; isDraggingHue = false; });
        document.addEventListener('touchend', () => { isDraggingSV = false; isDraggingHue = false; });
        
        // 3. Copy Buttons
        document.querySelectorAll('.copy-btn').forEach(button => {
            button.addEventListener('click', () => {
                copyToClipboard(button.getAttribute('data-target-id'));
            });
        });

        // 4. Save Button
        saveColorBtn.addEventListener('click', () => {
            saveColorToPalette(colorState.selectedSlotIndex, {
                hex: colorState.currentHex,
                rgb: colorState.currentRgb,
                hsl: colorState.currentHsl,
            });
        });

        // 5. Initial UI setup (run after elements are loaded)
        const rect = svPad.getBoundingClientRect();
        updateSelectorPosition(rect.width, 0);

        updateSvPadBaseColor();
        updateColor(); 
        
        // 6. Render the loaded palette
        renderPalette();
    });
  </script>
</body>
</html>
