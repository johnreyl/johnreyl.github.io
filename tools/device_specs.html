<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Advanced System Analyzer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            min-height: 100vh;
        }
        .spec-value {
            font-family: monospace;
        }
        .card-header {
            border-bottom: 2px solid theme('colors.indigo.500');
        }
    </style>
    <!-- Tailwind Configuration -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#4f46e5', /* Indigo 600 */
                    },
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-2">
            ðŸ”¬ Advanced System Analyzer
        </h1>
        <p class="text-gray-500 mb-8">
            Detailed client-side information collected via browser APIs.
        </p>

        <!-- Loading Indicator -->
        <div id="loading" class="text-center p-10 text-xl text-primary font-semibold">
            Analyzing device features...
        </div>

        <!-- Specifications Grid -->
        <div id="specsGrid" class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6" style="display: none;">
            <!-- Content will be populated here -->
        </div>

    </div>

    <script>
        // --- Utility Functions ---

        /** Format bytes to human-readable string. */
        function formatBytes(bytes) {
            if (bytes === undefined || bytes === null || bytes === 0) return "0 B";
            const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
            let i = Math.floor(Math.log(bytes) / Math.log(1024));
            return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sizes[i];
        }

        /** Format milliseconds to human-readable uptime. */
        function formatUptime(ms) {
            let sec = Math.floor(ms / 1000);
            let days = Math.floor(sec / 86400); sec %= 86400;
            let hrs = Math.floor(sec / 3600); sec %= 3600;
            let min = Math.floor(sec / 60); sec %= 60;
            return `${days}d ${hrs}h ${min}m ${sec}s`;
        }
        
        // --- Advanced Fingerprint Functions ---

        /** Generates a semi-unique hash based on Canvas rendering properties. */
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 30;
                const ctx = canvas.getContext('2d');
                if (!ctx) return "N/A (Context blocked)";

                const txt = 'Advanced Analyzer v1';
                
                // Drawing operations to expose rendering engine differences
                ctx.textBaseline = "top";
                ctx.font = "14px 'Arial'";
                ctx.fillStyle = "#f60";
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = "#069";
                ctx.fillText(txt, 2, 15);
                ctx.fillStyle = "rgba(102, 204, 0, 0.7)";
                ctx.fillText(txt, 4, 17);
                
                // Convert to a base64 string, then take a stable, short excerpt as the "hash"
                const dataURL = canvas.toDataURL();
                return dataURL.substring(dataURL.length - 35, dataURL.length - 1);
            } catch(e) {
                return "Error generating hash";
            }
        }

        /** Generates a hash based on the AudioContext rendering pipeline. (Async) */
        function getAudioFingerprint() {
            return new Promise(resolve => {
                let audioContext;
                try {
                    // Use OfflineAudioContext for deterministic, non-real-time generation
                    audioContext = new (window.OfflineAudioContext || window.webkitOfflineAudioContext)(1, 44100, 44100);
                    
                    const oscillator = audioContext.createOscillator();
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(10000, 0);
                    
                    const compressor = audioContext.createDynamicsCompressor();
                    compressor.threshold.setValueAtTime(-50, 0);
                    compressor.knee.setValueAtTime(40, 0);
                    compressor.ratio.setValueAtTime(12, 0);
                    compressor.attack.setValueAtTime(0, 0);
                    compressor.release.setValueAtTime(0.25, 0);

                    oscillator.connect(compressor);
                    compressor.connect(audioContext.destination);
                    oscillator.start(0);

                    audioContext.startRendering().then(buffer => {
                        // Get a segment of the buffer data
                        const data = buffer.getChannelData(0).slice(0, 500);
                        // Simple hash from data points
                        const hash = Array.from(data).map(x => Math.floor(x * 1000).toString(16)).join('');
                        resolve(hash.substring(0, 32) + '...');
                    }).catch(() => resolve('Rendering failed.'));
                } catch (e) {
                    resolve('N/A (API unsupported or blocked).');
                }
            });
        }
        
        /** Gets Graphics Card (GPU) info using WebGL. */
        function getGraphicsInfo() {
            let canvas = document.createElement("canvas");
            let gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
            if (!gl) return { renderer: "N/A", vendor: "N/A" };
            
            // Attempt to get debug info
            let debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
            return {
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Hidden (Privacy)",
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Hidden (Privacy)"
            };
        }

        // --- Data Collection (Main) ---

        async function getSpecs() {
            const specs = {
                'System': {
                    icon: 'ðŸ’»',
                    data: [
                        { key: "User Agent", value: navigator.userAgent },
                        { key: "Platform", value: navigator.platform || "Unknown" },
                        { key: "Language", value: navigator.language || "Unknown" },
                        { key: "Timezone", value: Intl.DateTimeFormat().resolvedOptions().timeZone },
                        { key: "Browser Uptime", value: formatUptime(performance.now()) },
                    ]
                },
                'Display & Viewport': {
                    icon: 'ðŸ–¥ï¸',
                    data: [
                        { key: "Screen Resolution (Device)", value: `${window.screen.width} x ${window.screen.height}` },
                        { key: "Viewport Resolution (Browser)", value: `${window.innerWidth} x ${window.innerHeight}` },
                        { key: "Color Depth", value: `${window.screen.colorDepth} bit` },
                        { key: "Pixel Ratio (DPR)", value: window.devicePixelRatio },
                        { key: "Touch Support", value: ("ontouchstart" in window || navigator.maxTouchPoints > 0) ? "Yes" : "No" },
                    ]
                },
                'Hardware & Performance': {
                    icon: 'âš™ï¸',
                    data: [
                        { key: "CPU Cores (Logical)", value: navigator.hardwareConcurrency || "Unknown" },
                        { key: "Device Memory (GB)", value: navigator.deviceMemory ? `${navigator.deviceMemory} GB` : "Unknown" },
                        { key: "Max Logical Storage Quota", value: "Estimating..." },
                        { key: "WebGL Renderer", value: getGraphicsInfo().renderer },
                        { key: "WebGL Vendor", value: getGraphicsInfo().vendor },
                    ]
                },
                'Network & Security': {
                    icon: 'ðŸŒ',
                    data: [
                        { key: "Online Status", value: navigator.onLine ? "Online" : "Offline" },
                        { key: "Connection Type", value: "Checking..." },
                        { key: "Effective Bandwidth", value: "Checking..." },
                        { key: "Canvas Fingerprint (Hash)", value: getCanvasFingerprint() },
                        { key: "Audio Fingerprint (Hash)", value: await getAudioFingerprint() },
                    ]
                }
            };

            // --- Async Data Collection ---

            // Storage
            const storageSpecs = specs['Hardware & Performance'].data;
            if (navigator.storage && navigator.storage.estimate) {
                try {
                    const est = await navigator.storage.estimate();
                    const quotaIndex = storageSpecs.findIndex(s => s.key === "Max Logical Storage Quota");
                    
                    storageSpecs.splice(quotaIndex, 1, 
                        { key: "Storage Used", value: formatBytes(est.usage) },
                        { key: "Storage Quota", value: formatBytes(est.quota) }
                    );
                } catch (e) {
                    const quotaIndex = storageSpecs.findIndex(s => s.key === "Max Logical Storage Quota");
                    storageSpecs[quotaIndex].value = "Error estimating storage";
                }
            } else {
                const quotaIndex = storageSpecs.findIndex(s => s.key === "Max Logical Storage Quota");
                storageSpecs[quotaIndex].value = "API not supported";
            }
            
            // Network
            const netSpecs = specs['Network & Security'].data;
            if (navigator.connection) {
                const conn = navigator.connection;
                netSpecs.find(s => s.key === "Connection Type").value = conn.effectiveType || conn.type || "Unknown";
                netSpecs.find(s => s.key === "Effective Bandwidth").value = conn.downlink ? `${conn.downlink} Mbps` : "Unknown";
            } else {
                netSpecs.find(s => s.key === "Connection Type").value = "N/A (API unsupported)";
                netSpecs.find(s => s.key === "Effective Bandwidth").value = "N/A (API unsupported)";
            }

            return specs;
        }

        // --- UI Rendering ---

        /** Renders all collected specs into the grid. */
        function renderSpecs(specs) {
            const grid = document.getElementById('specsGrid');
            grid.innerHTML = ''; // Clear existing content

            for (const category in specs) {
                const details = specs[category];

                const cardHtml = `
                    <div class="bg-white rounded-xl shadow-lg overflow-hidden border border-gray-100 transition-shadow hover:shadow-xl">
                        <div class="card-header p-4 flex items-center bg-indigo-50">
                            <span class="text-2xl mr-3">${details.icon}</span>
                            <h2 class="text-xl font-bold text-gray-800">${category}</h2>
                        </div>
                        <div class="p-4">
                            <table class="min-w-full divide-y divide-gray-200">
                                <tbody>
                                    ${details.data.map(item => `
                                        <tr>
                                            <td class="py-2 text-sm font-medium text-gray-600 w-1/3">${item.key}</td>
                                            <td class="py-2 text-sm text-gray-900 spec-value">${item.value}</td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                grid.innerHTML += cardHtml;
            }
        }

        // --- Initialization ---

        document.addEventListener('DOMContentLoaded', async () => {
            const loadingIndicator = document.getElementById('loading');
            const specsGrid = document.getElementById('specsGrid');
            
            // Simulate processing time for async functions
            const specs = await getSpecs();
            
            renderSpecs(specs);

            // Hide loading, show grid
            loadingIndicator.style.display = 'none';
            specsGrid.style.display = 'grid';
        });

    </script>
</body>
</html>
